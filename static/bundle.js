(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".html",".svg"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    
    require.define = function (filename, fn) {
        if (require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var queue = [];\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n    \n    if (canPost) {\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n    }\n    \n    return function (fn) {\n        if (canPost) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        }\n        else setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n//@ sourceURL=__browserify_process"));

require.define("vm",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = require(\"vm-browserify\")\n//@ sourceURL=vm"));

require.define("/node_modules/vm-browserify/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/vm-browserify/package.json"));

require.define("/node_modules/vm-browserify/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Object_keys = function (obj) {\n    if (Object.keys) return Object.keys(obj)\n    else {\n        var res = [];\n        for (var key in obj) res.push(key)\n        return res;\n    }\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nvar Script = exports.Script = function NodeScript (code) {\n    if (!(this instanceof Script)) return new Script(code);\n    this.code = code;\n};\n\nScript.prototype.runInNewContext = function (context) {\n    if (!context) context = {};\n    \n    var iframe = document.createElement('iframe');\n    if (!iframe.style) iframe.style = {};\n    iframe.style.display = 'none';\n    \n    document.body.appendChild(iframe);\n    \n    var win = iframe.contentWindow;\n    \n    forEach(Object_keys(context), function (key) {\n        win[key] = context[key];\n    });\n     \n    if (!win.eval && win.execScript) {\n        // win.eval() magically appears when this is called in IE:\n        win.execScript('null');\n    }\n    \n    var res = win.eval(this.code);\n    \n    forEach(Object_keys(win), function (key) {\n        context[key] = win[key];\n    });\n    \n    document.body.removeChild(iframe);\n    \n    return res;\n};\n\nScript.prototype.runInThisContext = function () {\n    return eval(this.code); // maybe...\n};\n\nScript.prototype.runInContext = function (context) {\n    // seems to be just runInNewContext on magical context objects which are\n    // otherwise indistinguishable from objects except plain old objects\n    // for the parameter segfaults node\n    return this.runInNewContext(context);\n};\n\nforEach(Object_keys(Script.prototype), function (name) {\n    exports[name] = Script[name] = function (code) {\n        var s = Script(code);\n        return s[name].apply(s, [].slice.call(arguments, 1));\n    };\n});\n\nexports.createScript = function (code) {\n    return exports.Script(code);\n};\n\nexports.createContext = Script.createContext = function (context) {\n    // not really sure what this one does\n    // seems to just make a shallow copy\n    var copy = {};\n    if(typeof context === 'object') {\n        forEach(Object_keys(context), function (key) {\n            copy[key] = context[key];\n        });\n    }\n    return copy;\n};\n\n//@ sourceURL=/node_modules/vm-browserify/index.js"));

require.define("/map/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Widget = require(\"./widget\")\n    , through = require(\"through\")\n\nmodule.exports = Map\n\nfunction Map() {\n    var widget = Widget(600, 400)\n        , blocks = {}\n        , map = {}\n\n    map.addEntity = addEntity\n    map.addBlock = addBlock\n    map.appendTo = widget.appendTo\n\n    return map\n\n    /*\n        When an entity emit deltas in position we pipe it through a\n            validator which checks collisions and then\n            pipe it back into the entity if the validator thinks there are\n            no collisions\n    */\n    function addEntity(entity) {\n        entity.pipe(through(detectCollisions)).pipe(entity)\n\n        addBlock(entity)\n\n        /*\n\n        */\n        function detectCollisions(data) {\n            //console.log(\"got changes\", data)\n\n            var changes = data[0]\n                , diffX = changes.x || 0\n                , diffY = changes.y || 0\n\n            entity.x += diffX\n            entity.y += diffY\n\n            this.emit(\"data\", [{\n                x: entity.x\n                , y: entity.y\n            }, data[1], data[2]])\n        }\n    }\n\n    function addBlock(block) {\n        var gridPoint = getGrid(block)\n            , loc = gridPoint.x + \":\" + gridPoint.y\n            , list = blocks[loc]\n\n        if (list) {\n            list.push(block)\n        } else {\n            blocks[loc] = [block]\n        }\n\n        widget.addBlock(block)\n    }\n}\n\nfunction getGrid(point) {\n    var x = point.x\n        , y = point.y\n        , diffX = x % 20\n        , diffY = y % 20\n\n    return {\n        x: x - diffX\n        , y: y - diffY\n    }\n}\n//@ sourceURL=/map/index.js"));

require.define("/map/widget.js",Function(['require','module','exports','__dirname','__filename','process'],"var svg = require(\"./map.svg\")\n    , Fragment = require(\"fragment\")\n\nmodule.exports = Widget\n\nfunction Widget(width, height) {\n    var elem = Fragment(svg).firstChild\n    elem.setAttribute(\"width\", width)\n    elem.setAttribute(\"height\", height)\n\n    return {\n        appendTo: appendTo\n        , addBlock: addBlock\n    }\n    \n    function appendTo(other) {\n        other.appendChild(elem)\n    }\n\n    function addBlock(block) {\n        block.appendTo(elem)\n    }\n}\n//@ sourceURL=/map/widget.js"));

require.define("/map/map.svg",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = '<svg class=\"svg-elem\">\\n</svg>'\n//@ sourceURL=/map/map.svg"));

require.define("/node_modules/fragment/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {}\n//@ sourceURL=/node_modules/fragment/package.json"));

require.define("/node_modules/fragment/index.js",Function(['require','module','exports','__dirname','__filename','process'],"Fragment.Element = Element\n\nmodule.exports = Fragment\n\nfunction Fragment(html, elementName) {\n    var el = document.createElement(elementName || \"div\")\n        , fragment = document.createDocumentFragment()\n\n    el.innerHTML = html\n\n    while (el.hasChildNodes()) {\n        fragment.appendChild(el.firstChild)\n    }\n\n    return fragment\n}\n\nfunction Element(html, elementName) {\n    var el = document.createElement(elementName || \"div\")\n\n    el.innerHTML = html\n\n    var child = el.firstChild\n    el.removeChild(child)\n\n    return child\n}\n//@ sourceURL=/node_modules/fragment/index.js"));

require.define("/node_modules/through/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/through/package.json"));

require.define("/node_modules/through/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end) {\n  write = write || function (data) { this.emit('data', data) }\n  end = end || function () { this.emit('end') }\n\n  var ended = false, destroyed = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false  \n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here. \n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  stream.end = function (data) {\n    if(ended) return \n    //this breaks, because pipe doesn't check writable before calling end.\n    //throw new Error('cannot call end twice')\n    ended = true\n    if(arguments.length) stream.write(data)\n    this.writable = false\n    end.call(this)\n    if(!this.readable)\n      this.destroy()\n  }\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    stream.writable = stream.readable = false\n    stream.emit('close')\n  }\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    stream.emit('pause')\n  }\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n      stream.emit('drain')\n    }\n  }\n  return stream\n}\n\n\n//@ sourceURL=/node_modules/through/index.js"));

require.define("stream",Function(['require','module','exports','__dirname','__filename','process'],"var events = require('events');\nvar util = require('util');\n\nfunction Stream() {\n  events.EventEmitter.call(this);\n}\nutil.inherits(Stream, events.EventEmitter);\nmodule.exports = Stream;\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once, and\n  // only when all sources have ended.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    dest._pipeCount = dest._pipeCount || 0;\n    dest._pipeCount++;\n\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (this.listeners('error').length === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('end', cleanup);\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('end', cleanup);\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n//@ sourceURL=stream"));

require.define("events",Function(['require','module','exports','__dirname','__filename','process'],"if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = list.indexOf(listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n//@ sourceURL=events"));

require.define("util",Function(['require','module','exports','__dirname','__filename','process'],"var events = require('events');\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (x === null || typeof x !== 'object') {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Boolean} showHidden Flag that shows hidden (not enumerable)\n *    properties of objects.\n * @param {Number} depth Depth in which to descend in object. Default is 2.\n * @param {Boolean} colors Flag to turn on ANSI escape codes to color the\n *    output. Default is false (no coloring).\n */\nfunction inspect(obj, showHidden, depth, colors) {\n  var ctx = {\n    showHidden: showHidden,\n    seen: [],\n    stylize: colors ? stylizeWithColor : stylizeNoColor\n  };\n  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\nvar colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\nvar styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + colors[style][0] + 'm' + str +\n           '\\u001b[' + colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (value && typeof value.inspect === 'function' &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    return String(value.inspect(recurseTimes));\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object_keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object_getOwnPropertyNames(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (typeof value === 'function') {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (typeof value === 'function') {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  switch (typeof value) {\n    case 'undefined':\n      return ctx.stylize('undefined', 'undefined');\n\n    case 'string':\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                               .replace(/'/g, \"\\\\'\")\n                                               .replace(/\\\\\"/g, '\"') + '\\'';\n      return ctx.stylize(simple, 'string');\n\n    case 'number':\n      return ctx.stylize('' + value, 'number');\n\n    case 'boolean':\n      return ctx.stylize('' + value, 'boolean');\n  }\n  // For some reason typeof null is \"object\", so special case here.\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (Object.prototype.hasOwnProperty.call(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!visibleKeys.hasOwnProperty(key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (recurseTimes === null) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (typeof name === 'undefined') {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== 'object') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction isError(e) {\n  return typeof e === 'object' && objectToString(e) === '[object Error]';\n}\nexports.isError = isError;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\n//@ sourceURL=util"));

require.define("/player/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Widget = require(\"./widget\")\n    , DeltaStream = require(\"delta-stream\")\n    , ArrowKeys = require(\"arrow-keys\")\n    , duplex = require(\"duplexer\")\n    , SPEED = 5\n\nmodule.exports = Player\n\n/*\n    A player is a stream which emits requested changes in state and which when\n    written to changes the actual state.\n\n    Generally you hook the input up to the change requests and you hook the\n    state upto the widget for rendering\n*/\nfunction Player(x, y) {\n    var input = ArrowKeys()\n        , widget = Widget(x, y)\n        , player = duplex(widget, input)\n\n    player.appendTo = widget.appendTo\n    player.x = x\n    player.y = y\n\n    return player\n}\n//@ sourceURL=/player/index.js"));

require.define("/player/widget.js",Function(['require','module','exports','__dirname','__filename','process'],"var Element = require(\"svg\")\n    , svg = require(\"./player\")\n    , AttributeStream = require(\"./attribute\")\n\nmodule.exports = Widget\n\nfunction Widget(x, y) {\n    var elem = Element(svg)\n        , stream = AttributeStream(elem)\n\n    elem.setAttribute(\"x\", x)\n    elem.setAttribute(\"y\", y)\n\n    stream.appendTo = appendTo\n\n    return stream\n\n    function appendTo(other) {\n        other.appendChild(elem)\n    }\n}\n//@ sourceURL=/player/widget.js"));

require.define("/node_modules/svg/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/svg/package.json"));

require.define("/node_modules/svg/index.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = Element\n\nfunction Element(svgText) {\n    var parser = new DOMParser()\n        , xmlText =  \"<svg xmlns=\\'http://www.w3.org/2000/svg\\'>\" +\n            svgText + \"</svg>\"\n        , docElem = parser.parseFromString(xmlText, \"text/xml\").documentElement\n\n    var node = docElem.firstChild\n    document.importNode(node, true)\n    return node\n}\n//@ sourceURL=/node_modules/svg/index.js"));

require.define("/player/player.svg",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = '<rect width=\"20\" height=\"20\" fill=\"red\" stroke=\"black\" />'\n//@ sourceURL=/player/player.svg"));

require.define("/player/attribute.js",Function(['require','module','exports','__dirname','__filename','process'],"var forEach = require(\"iterators\").forEachSync\n    , through = require(\"through\")\n\nmodule.exports = AttributeStream\n\nfunction AttributeStream(elem) {\n    var stream = through(updateAttribute)\n\n    return stream\n\n    function updateAttribute(data) {\n        var changes = data[0]\n\n        forEach(changes, setAttribute)\n    }\n\n    function setAttribute(value, key) {\n        elem.setAttribute(key, value)\n    }\n}\n//@ sourceURL=/player/attribute.js"));

require.define("/node_modules/iterators/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/iterators/package.json"));

require.define("/node_modules/iterators/index.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\n    // sync\n    forEachSync: require(\"./lib/sync/forEach\")\n    , filterSync: require(\"./lib/sync/filter\")\n    , mapSync: require(\"./lib/sync/map\")\n    , reduceSync: require(\"./lib/sync/reduce\")\n    , reduceRightSync: require(\"./lib/sync/reduceRight\")\n    , everySync: require(\"./lib/sync/every\")\n    , someSync: require(\"./lib/sync/some\")\n    // async\n    , forEach: require(\"./lib/async/forEach\")\n    , filter: require(\"./lib/async/filter\")\n    , map: require(\"./lib/async/map\")\n    , reduce: require(\"./lib/async/reduce\")\n    , reduceRight: require(\"./lib/async/reduceRight\")\n    , every: require(\"./lib/async/every\")\n    , some: require(\"./lib/async/some\")\n}\n//@ sourceURL=/node_modules/iterators/index.js"));

require.define("/node_modules/iterators/lib/sync/forEach.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = forEach\n\nfunction forEach(list, iterator, context) {\n    var keys = Object.keys(list)\n\n    if (arguments.length < 3) {\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        iterator.call(context, value, key, list)\n    }\n}\n//@ sourceURL=/node_modules/iterators/lib/sync/forEach.js"));

require.define("/node_modules/iterators/lib/sync/filter.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = filter\n\nfunction filter(list, iterator, context) {\n    var returnValue = Array.isArray(list) ? [] : {}\n        , keys = Object.keys(list)\n\n    if (arguments.length < 3) {\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n            , keepValue = iterator.call(context, value, key, list)\n\n        if (keepValue) {\n            if (Array.isArray(returnValue)) {\n                returnValue.push(value)\n            } else {\n                returnValue[key] = value\n            }\n        }\n    }\n\n    return returnValue\n}\n//@ sourceURL=/node_modules/iterators/lib/sync/filter.js"));

require.define("/node_modules/iterators/lib/sync/map.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = map\n\nfunction map(list, iterator, context) {\n    var returnValue = Array.isArray(list) ? [] : {}\n        , keys = Object.keys(list)\n\n    if (arguments.length < 3) {\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n            , newValue = iterator.call(context, value, key, list)\n\n        returnValue[key] = newValue\n    }\n\n    return returnValue\n}\n//@ sourceURL=/node_modules/iterators/lib/sync/map.js"));

require.define("/node_modules/iterators/lib/sync/reduce.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = reduce\n\nfunction reduce(list, iterator, context, accumulator) {\n    var keys = Object.keys(list)\n        , i = 0\n\n    if (arguments.length === 2) {\n        context = this\n        accumulator = list[0]\n        i = 1\n    } else if (arguments.length === 3) {\n        accumulator = context\n        context = this\n    }\n\n    for (var len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n\n        accumulator = iterator.call(context, accumulator, value, key, list)\n    }\n\n    return accumulator\n}\n//@ sourceURL=/node_modules/iterators/lib/sync/reduce.js"));

require.define("/node_modules/iterators/lib/sync/reduceRight.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = reduceRight\n\nfunction reduceRight(list, iterator, context, accumulator) {\n    var keys = Object.keys(list)\n        , len = keys.length\n        , i = len - 1\n\n    if (arguments.length === 2) {\n        context = this\n        accumulator = list[i]\n        i--\n    } else if (arguments.length === 3) {\n        accumulator = context\n        context = this\n    }\n\n    for (; i >= 0; i--) {\n        var key = keys[i]\n            , value = list[key]\n\n        accumulator = iterator.call(context, accumulator, value, key, list)\n    }\n\n    return accumulator\n}\n//@ sourceURL=/node_modules/iterators/lib/sync/reduceRight.js"));

require.define("/node_modules/iterators/lib/sync/every.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = every\n\nfunction every(list, iterator, context) {\n    var keys = Object.keys(list)\n        , result\n\n    if (arguments.length < 3) {\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        result = iterator.call(context, value, key, list)\n\n        if (!result) {\n            return result\n        }\n    }\n\n    return result\n}\n//@ sourceURL=/node_modules/iterators/lib/sync/every.js"));

require.define("/node_modules/iterators/lib/sync/some.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = some\n\nfunction some(list, iterator, context) {\n    var keys = Object.keys(list)\n        , result = false\n\n    if (arguments.length < 3) {\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        result = iterator.call(context, value, key, list)\n\n        if (result) {\n            return result\n        }\n    }\n\n    return result\n}\n//@ sourceURL=/node_modules/iterators/lib/sync/some.js"));

require.define("/node_modules/iterators/lib/async/forEach.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = forEach\n\nfunction forEach(list, iterator, context, callback) {\n    var keys = Object.keys(list)\n        , count = keys.length\n\n    if (typeof context === \"function\") {\n        callback = context\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        invokeIterator(iterator, next, context, value, key, list)\n    }\n\n    function next(err) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        if (--count === 0) {\n            callback && callback(null)\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, value, done)\n    } else if (length === 3) {\n        iterator.call(context, value, key, done)\n    } else {\n        iterator.call(context, value, key, list, done)\n    }\n}\n//@ sourceURL=/node_modules/iterators/lib/async/forEach.js"));

require.define("/node_modules/iterators/lib/async/filter.js",Function(['require','module','exports','__dirname','__filename','process'],"var partial = require(\"ap\").partial\n\nmodule.exports = filter\n\nfunction filter(list, iterator, context, callback) {\n    var keys = Object.keys(list)\n        , returnValue = Array.isArray(list) ? [] : {}\n        , count = keys.length\n\n    if (typeof context === \"function\") {\n        callback = context\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        invokeIterator(iterator,\n            partial(next, value, key), context, value, key, list)\n    }\n\n    function next(value, key, err, keepValue) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        if (keepValue) {\n            if (Array.isArray(returnValue)) {\n                returnValue.push(value)\n            } else {\n                returnValue[key] = value\n            }\n        }\n\n        if (--count === 0) {\n            callback && callback(null, returnValue)\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, value, done)\n    } else if (length === 3) {\n        iterator.call(context, value, key, done)\n    } else {\n        iterator.call(context, value, key, list, done)\n    }\n}\n//@ sourceURL=/node_modules/iterators/lib/async/filter.js"));

require.define("/node_modules/iterators/node_modules/ap/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"./index.js\"}\n//@ sourceURL=/node_modules/iterators/node_modules/ap/package.json"));

require.define("/node_modules/iterators/node_modules/ap/index.js",Function(['require','module','exports','__dirname','__filename','process'],"exports = module.exports = ap;\nfunction ap (args, fn) {\n    return function () {\n        return fn.apply(this, args.concat.apply(args, arguments));\n    };\n}\n\nexports.pa = pa;\nfunction pa (args, fn) {\n    return function () {\n        return fn.apply(this, [].slice.call(arguments).concat(args));\n    };\n}\n\nexports.apa = apa;\nfunction apa (left, right, fn) {\n    return function () {\n        return fn.apply(this,\n            left.concat.apply(left, arguments).concat(right)\n        );\n    };\n}\n\nexports.partial = partial;\nfunction partial (fn) {\n    var args = [].slice.call(arguments, 1);\n    return ap(args, fn);\n}\n\nexports.partialRight = partialRight;\nfunction partialRight (fn) {\n    var args = [].slice.call(arguments, 1);\n    return pa(args, fn);\n}\n\nexports.curry = curry;\nfunction curry (fn) {\n    return partial(partial, fn);\n}\n\nexports.curryRight = function curryRight (fn) {\n    return partial(partialRight, fn);\n}\n\n//@ sourceURL=/node_modules/iterators/node_modules/ap/index.js"));

require.define("/node_modules/iterators/lib/async/map.js",Function(['require','module','exports','__dirname','__filename','process'],"var partial = require(\"ap\").partial\n\nmodule.exports = map\n\nfunction map(list, iterator, context, callback) {\n    var keys = Object.keys(list)\n        , returnValue = Array.isArray(list) ? [] : {}\n        , count = keys.length\n\n    if (typeof context === \"function\") {\n        callback = context\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        invokeIterator(iterator,\n            partial(next, key), context, value, key, list)\n    }\n\n    function next(key, err, newValue) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        returnValue[key] = newValue\n\n        if (--count === 0) {\n            callback && callback(null, returnValue)\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, value, done)\n    } else if (length === 3) {\n        iterator.call(context, value, key, done)\n    } else {\n        iterator.call(context, value, key, list, done)\n    }\n}\n//@ sourceURL=/node_modules/iterators/lib/async/map.js"));

require.define("/node_modules/iterators/lib/async/reduce.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = reduce\n\nfunction reduce(list, iterator, context, accumulator, callback) {\n    var keys = Object.keys(list)\n        , count = keys.length\n\n    if (arguments.length === 3) {\n        callback = context\n        context = this\n        accumulator = list[0]\n        keys.shift()\n        count--\n    } else if (arguments.length === 4) {\n        callback = accumulator\n        accumulator = context\n        context = this\n    }\n\n    go()\n\n    function go() {\n        var key = keys.shift()\n            , value = list[key]\n\n        invokeIterator(iterator, next, context, accumulator, value, key, list)\n    }\n\n    function next(err, value) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        accumulator = value\n\n        if (--count === 0) {\n            callback && callback(null, accumulator)\n        } else {\n            go()\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, acc, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, acc, done)\n    } else if (length === 3) {\n        iterator.call(context, acc, value, done)\n    } else if (length === 4) {\n        iterator.call(context, acc, value, key, done)\n    } else {\n        iterator.call(context, acc, value, key, list, done)\n    }\n}\n//@ sourceURL=/node_modules/iterators/lib/async/reduce.js"));

require.define("/node_modules/iterators/lib/async/reduceRight.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = forEach\n\nfunction forEach(list, iterator, context, accumulator, callback) {\n    var keys = Object.keys(list)\n        , len = keys.length\n        , count = keys.length\n\n    if (arguments.length === 3) {\n        callback = context\n        context = this\n        accumulator = list[len - 1]\n        keys.pop()\n        count--\n    } else if (arguments.length === 4) {\n        callback = accumulator\n        accumulator = context\n        context = this\n    }\n\n    go()\n\n    function go() {\n        var key = keys.pop()\n            , value = list[key]\n\n        invokeIterator(iterator, next, context, accumulator, value, key, list)\n    }\n\n    function next(err, value) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        accumulator = value\n\n        if (--count === 0) {\n            callback && callback(null, accumulator)\n        } else {\n            go()\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, acc, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, acc, done)\n    } else if (length === 3) {\n        iterator.call(context, acc, value, done)\n    } else if (length === 4) {\n        iterator.call(context, acc, value, key, done)\n    } else {\n        iterator.call(context, acc, value, key, list, done)\n    }\n}\n//@ sourceURL=/node_modules/iterators/lib/async/reduceRight.js"));

require.define("/node_modules/iterators/lib/async/every.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = every\n\nfunction every(list, iterator, context, callback) {\n    var keys = Object.keys(list)\n        , count = keys.length\n\n    if (typeof context === \"function\") {\n        callback = context\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        invokeIterator(iterator, next, context, value, key, list)\n    }\n\n    function next(err, result) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        if (!result) {\n            return callback && callback(null, result)\n        }\n\n        if (--count === 0) {\n            callback && callback(null, result)\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, value, done)\n    } else if (length === 3) {\n        iterator.call(context, value, key, done)\n    } else {\n        iterator.call(context, value, key, list, done)\n    }\n}\n//@ sourceURL=/node_modules/iterators/lib/async/every.js"));

require.define("/node_modules/iterators/lib/async/some.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = forEach\n\nfunction forEach(list, iterator, context, callback) {\n    var keys = Object.keys(list)\n        , count = keys.length\n\n    if (typeof context === \"function\") {\n        callback = context\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        invokeIterator(iterator, next, context, value, key, list)\n    }\n\n    function next(err, result) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        if (result) {\n            return callback && callback(null, result)\n        }\n\n        if (--count === 0) {\n            callback && callback(null, result)\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, value, done)\n    } else if (length === 3) {\n        iterator.call(context, value, key, done)\n    } else {\n        iterator.call(context, value, key, list, done)\n    }\n}\n//@ sourceURL=/node_modules/iterators/lib/async/some.js"));

require.define("/node_modules/delta-stream/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/delta-stream/package.json"));

require.define("/node_modules/delta-stream/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var invert = require(\"invert-stream\")\n    , uuid = require(\"node-uuid\")\n    , pipeline = require(\"event-stream\").pipeline\n    , through = require(\"through\")\n    , partial = require(\"ap\").partial\n\nvar Observable = require(\"./interfaces/observable\")\n\nDeltaStream.fromObservable = Observable.from\n\nmodule.exports = DeltaStream\n\nfunction DeltaStream(id) {\n    var inverted = invert()\n        , rejectSource = through(reject)\n        , addSource = through(add)\n        , stream = pipeline(rejectSource, inverted, addSource)\n\n    stream.id = id || uuid()\n    stream.other = inverted.other\n    stream.createObservable = partial(Observable, stream)\n\n    return stream\n\n    function reject(data) {\n        if (data[2] !== stream.id) {\n            this.emit(\"data\", data)\n        }\n    }\n\n    function add(data) {\n        if (!data[2]) {\n            data[2] = stream.id\n        }\n        this.emit(\"data\", data)\n    }\n}\n//@ sourceURL=/node_modules/delta-stream/index.js"));

require.define("/node_modules/delta-stream/node_modules/invert-stream/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {}\n//@ sourceURL=/node_modules/delta-stream/node_modules/invert-stream/package.json"));

require.define("/node_modules/delta-stream/node_modules/invert-stream/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Stream = require('stream')\nvar inherits = require('util').inherits\n\ninherits(InvertStream, Stream)\n\nfunction InvertStream (other) {\n  this.writable = this.readable = true\n  this.paused = false\n  if(other) {\n    this.other = other\n    other.other = this\n    this.b = other\n    other.a = this\n  }\n}\n\nInvertStream.prototype.write = \n  function (data) {\n    this.other.emit('data', data)\n    return !this.paused\n  }\n\nInvertStream.prototype.end = \n function () {\n    this.writable = false\n    this.other.readable = false\n    this.other.emit('end')\n  }\nInvertStream.prototype.destroy = \n  function () {\n    this.writable = this.readable = \n    this.other.readable = this.other.writable = false\n    this.emit('close')\n    this.other.emit('close')\n  }\n\nInvertStream.prototype.pause = \n  function () {\n    this.other.paused = true\n    this.other.emit('pause')\n    return this\n  }\n\nInvertStream.prototype.resume = \n  function () {\n    this.other.paused = false\n    this.other.emit('drain')\n    return this\n  }\n\nexports = \nmodule.exports = function () {\n  return new InvertStream(new InvertStream())\n}\n\nexports.InvertStream = InvertStream\n\n\n//@ sourceURL=/node_modules/delta-stream/node_modules/invert-stream/index.js"));

require.define("/node_modules/delta-stream/node_modules/node-uuid/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"./uuid.js\"}\n//@ sourceURL=/node_modules/delta-stream/node_modules/node-uuid/package.json"));

require.define("/node_modules/delta-stream/node_modules/node-uuid/uuid.js",Function(['require','module','exports','__dirname','__filename','process'],"//     node-uuid/uuid.js\n//\n//     Copyright (c) 2010 Robert Kieffer\n//     Dual licensed under the MIT and GPL licenses.\n//     Documentation and details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  // Unique ID creation requires a high quality random # generator, but\n  // Math.random() does not guarantee \"cryptographic quality\".  So we feature\n  // detect for more robust APIs, normalizing each method to return 128-bits\n  // (16 bytes) of random data.\n  var mathRNG, nodeRNG, whatwgRNG;\n\n  // Math.random()-based RNG.  All platforms, very fast, unknown quality\n  var _rndBytes = new Array(16);\n  mathRNG = function() {\n    var r, b = _rndBytes, i = 0;\n\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      b[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return b;\n  }\n\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // WebKit only (currently), moderately fast, high quality\n  if (_global.crypto && crypto.getRandomValues) {\n    var _rnds = new Uint32Array(4);\n    whatwgRNG = function() {\n      crypto.getRandomValues(_rnds);\n\n      for (var c = 0 ; c < 16; c++) {\n        _rndBytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;\n      }\n      return _rndBytes;\n    }\n  }\n\n  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html\n  // Node.js only, moderately fast, high quality\n  try {\n    var _rb = require('crypto').randomBytes;\n    nodeRNG = _rb && function() {\n      return _rb(16);\n    };\n  } catch (e) {}\n\n  // Select RNG with best quality\n  var _rng = nodeRNG || whatwgRNG || mathRNG;\n\n  // Buffer class to use\n  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;\n\n  // Maps for number <-> hex string conversion\n  var _byteToHex = [];\n  var _hexToByte = {};\n  for (var i = 0; i < 256; i++) {\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    _hexToByte[_byteToHex[i]] = i;\n  }\n\n  // **`parse()` - Parse a UUID into it's component bytes**\n  function parse(s, buf, offset) {\n    var i = (buf && offset) || 0, ii = 0;\n\n    buf = buf || [];\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(byte) {\n      if (ii < 16) { // Don't overflow!\n        buf[i + ii++] = _hexToByte[byte];\n      }\n    });\n\n    // Zero out remaining bytes if string was short\n    while (ii < 16) {\n      buf[i + ii++] = 0;\n    }\n\n    return buf;\n  }\n\n  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n  function unparse(buf, offset) {\n    var i = offset || 0, bth = _byteToHex;\n    return  bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]];\n  }\n\n  // **`v1()` - Generate time-based UUID**\n  //\n  // Inspired by https://github.com/LiosK/UUID.js\n  // and http://docs.python.org/library/uuid.html\n\n  // random #'s we need to init node and clockseq\n  var _seedBytes = _rng();\n\n  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n  var _nodeId = [\n    _seedBytes[0] | 0x01,\n    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n  ];\n\n  // Per 4.2.2, randomize (14 bit) clockseq\n  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n  // Previous uuid creation time\n  var _lastMSecs = 0, _lastNSecs = 0;\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n\n    options = options || {};\n\n    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;\n\n    // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n    var msecs = options.msecs != null ? options.msecs : new Date().getTime();\n\n    // Per 4.2.1.2, use count of uuid's generated during the current clock\n    // cycle to simulate higher resolution clock\n    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;\n\n    // Time since last uuid creation (in msecs)\n    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n    // Per 4.2.1.2, Bump clockseq on clock regression\n    if (dt < 0 && options.clockseq == null) {\n      clockseq = clockseq + 1 & 0x3fff;\n    }\n\n    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n    // time interval\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {\n      nsecs = 0;\n    }\n\n    // Per 4.2.1.2 Throw error if too many uuids are requested\n    if (nsecs >= 10000) {\n      throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n    }\n\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n\n    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n    msecs += 12219292800000;\n\n    // `time_low`\n    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    b[i++] = tl >>> 24 & 0xff;\n    b[i++] = tl >>> 16 & 0xff;\n    b[i++] = tl >>> 8 & 0xff;\n    b[i++] = tl & 0xff;\n\n    // `time_mid`\n    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n    b[i++] = tmh >>> 8 & 0xff;\n    b[i++] = tmh & 0xff;\n\n    // `time_high_and_version`\n    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n    b[i++] = tmh >>> 16 & 0xff;\n\n    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n    b[i++] = clockseq >>> 8 | 0x80;\n\n    // `clock_seq_low`\n    b[i++] = clockseq & 0xff;\n\n    // `node`\n    var node = options.node || _nodeId;\n    for (var n = 0; n < 6; n++) {\n      b[i + n] = node[n];\n    }\n\n    return buf ? buf : unparse(b);\n  }\n\n  // **`v4()` - Generate random UUID**\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v4(options, buf, offset) {\n    // Deprecated - 'format' argument, as supported in v1.2\n    var i = buf && offset || 0;\n\n    if (typeof(options) == 'string') {\n      buf = options == 'binary' ? new BufferClass(16) : null;\n      options = null;\n    }\n    options = options || {};\n\n    var rnds = options.random || (options.rng || _rng)();\n\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n    // Copy bytes to buffer, if provided\n    if (buf) {\n      for (var ii = 0; ii < 16; ii++) {\n        buf[i + ii] = rnds[ii];\n      }\n    }\n\n    return buf || unparse(rnds);\n  }\n\n  // Export public API\n  var uuid = v4;\n  uuid.v1 = v1;\n  uuid.v4 = v4;\n  uuid.parse = parse;\n  uuid.unparse = unparse;\n  uuid.BufferClass = BufferClass;\n\n  // Export RNG options\n  uuid.mathRNG = mathRNG;\n  uuid.nodeRNG = nodeRNG;\n  uuid.whatwgRNG = whatwgRNG;\n\n  if (typeof(module) != 'undefined') {\n    // Play nice with node.js\n    module.exports = uuid;\n  } else {\n    // Play nice with browsers\n    var _previousRoot = _global.uuid;\n\n    // **`noConflict()` - (browser only) to reset global 'uuid' var**\n    uuid.noConflict = function() {\n      _global.uuid = _previousRoot;\n      return uuid;\n    }\n    _global.uuid = uuid;\n  }\n}());\n\n//@ sourceURL=/node_modules/delta-stream/node_modules/node-uuid/uuid.js"));

require.define("crypto",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = require(\"crypto-browserify\")\n//@ sourceURL=crypto"));

require.define("/node_modules/crypto-browserify/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {}\n//@ sourceURL=/node_modules/crypto-browserify/package.json"));

require.define("/node_modules/crypto-browserify/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var sha = require('./sha')\nvar rng = require('./rng')\n\nvar algorithms = {\n  sha1: {\n    hex: sha.hex_sha1,\n    binary: sha.b64_sha1,\n    ascii: sha.str_sha1\n  }\n}\n\nfunction error () {\n  var m = [].slice.call(arguments).join(' ')\n  throw new Error([\n    m,\n    'we accept pull requests',\n    'http://github.com/dominictarr/crypto-browserify'\n    ].join('\\n'))\n}\n\nexports.createHash = function (alg) {\n  alg = alg || 'sha1'\n  if(!algorithms[alg])\n    error('algorithm:', alg, 'is not yet supported')\n  var s = ''\n  var _alg = algorithms[alg]\n  return {\n    update: function (data) {\n      s += data\n      return this\n    },\n    digest: function (enc) {\n      enc = enc || 'binary'\n      var fn\n      if(!(fn = _alg[enc]))\n        error('encoding:', enc , 'is not yet supported for algorithm', alg)\n      var r = fn(s)\n      s = null //not meant to use the hash after you've called digest.\n      return r\n    }\n  }\n}\n\nexports.randomBytes = function(size, callback) {\n  if (callback && callback.call) {\n    try {\n      callback.call(this, undefined, rng(size));\n    } catch (err) { callback(err); }\n  } else {\n    return rng(size);\n  }\n}\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\n;['createCredentials'\n, 'createHmac'\n, 'createCypher'\n, 'createCypheriv'\n, 'createDecipher'\n, 'createDecipheriv'\n, 'createSign'\n, 'createVerify'\n, 'createDeffieHellman'\n, 'pbkdf2'].forEach(function (name) {\n  exports[name] = function () {\n    error('sorry,', name, 'is not implemented yet')\n  }\n})\n\n//@ sourceURL=/node_modules/crypto-browserify/index.js"));

require.define("/node_modules/crypto-browserify/sha.js",Function(['require','module','exports','__dirname','__filename','process'],"/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nexports.hex_sha1 = hex_sha1;\nexports.b64_sha1 = b64_sha1;\nexports.str_sha1 = str_sha1;\nexports.hex_hmac_sha1 = hex_hmac_sha1;\nexports.b64_hmac_sha1 = b64_hmac_sha1;\nexports.str_hmac_sha1 = str_hmac_sha1;\n\n/*\n * Configurable variables. You may need to tweak these to be compatible with\n * the server-side, but the defaults work in most cases.\n */\nvar hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */\nvar b64pad  = \"\"; /* base-64 pad character. \"=\" for strict RFC compliance   */\nvar chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */\n\n/*\n * These are the functions you'll usually want to call\n * They take string arguments and return either hex or base-64 encoded strings\n */\nfunction hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}\nfunction b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}\nfunction str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}\nfunction hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}\nfunction b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}\nfunction str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}\n\n/*\n * Perform a simple self-test to see if the VM is working\n */\nfunction sha1_vm_test()\n{\n  return hex_sha1(\"abc\") == \"a9993e364706816aba3e25717850c26c9cd0d89d\";\n}\n\n/*\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\n */\nfunction core_sha1(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << (24 - len % 32);\n  x[((len + 64 >> 9) << 4) + 15] = len;\n\n  var w = Array(80);\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n  var e = -1009589776;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    var olde = e;\n\n    for(var j = 0; j < 80; j++)\n    {\n      if(j < 16) w[j] = x[i + j];\n      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n    e = safe_add(e, olde);\n  }\n  return Array(a, b, c, d, e);\n\n}\n\n/*\n * Perform the appropriate triplet combination function for the current\n * iteration\n */\nfunction sha1_ft(t, b, c, d)\n{\n  if(t < 20) return (b & c) | ((~b) & d);\n  if(t < 40) return b ^ c ^ d;\n  if(t < 60) return (b & c) | (b & d) | (c & d);\n  return b ^ c ^ d;\n}\n\n/*\n * Determine the appropriate additive constant for the current iteration\n */\nfunction sha1_kt(t)\n{\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n         (t < 60) ? -1894007588 : -899497514;\n}\n\n/*\n * Calculate the HMAC-SHA1 of a key and some data\n */\nfunction core_hmac_sha1(key, data)\n{\n  var bkey = str2binb(key);\n  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);\n\n  var ipad = Array(16), opad = Array(16);\n  for(var i = 0; i < 16; i++)\n  {\n    ipad[i] = bkey[i] ^ 0x36363636;\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\n  }\n\n  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);\n  return core_sha1(opad.concat(hash), 512 + 160);\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\n/*\n * Convert an 8-bit or 16-bit string to an array of big-endian words\n * In 8-bit function, characters >255 have their hi-byte silently ignored.\n */\nfunction str2binb(str)\n{\n  var bin = Array();\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < str.length * chrsz; i += chrsz)\n    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);\n  return bin;\n}\n\n/*\n * Convert an array of big-endian words to a string\n */\nfunction binb2str(bin)\n{\n  var str = \"\";\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < bin.length * 32; i += chrsz)\n    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);\n  return str;\n}\n\n/*\n * Convert an array of big-endian words to a hex string.\n */\nfunction binb2hex(binarray)\n{\n  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i++)\n  {\n    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +\n           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);\n  }\n  return str;\n}\n\n/*\n * Convert an array of big-endian words to a base-64 string\n */\nfunction binb2b64(binarray)\n{\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i += 3)\n  {\n    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)\n                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )\n                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);\n    for(var j = 0; j < 4; j++)\n    {\n      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;\n      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);\n    }\n  }\n  return str;\n}\n\n\n//@ sourceURL=/node_modules/crypto-browserify/sha.js"));

require.define("/node_modules/crypto-browserify/rng.js",Function(['require','module','exports','__dirname','__filename','process'],"// Original code adapted from Robert Kieffer.\n// details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  var mathRNG, whatwgRNG;\n\n  // NOTE: Math.random() does not guarantee \"cryptographic quality\"\n  mathRNG = function(size) {\n    var bytes = new Array(size);\n    var r;\n\n    for (var i = 0, r; i < size; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return bytes;\n  }\n\n  // currently only available in webkit-based browsers.\n  if (_global.crypto && crypto.getRandomValues) {\n    var _rnds = new Uint32Array(4);\n    whatwgRNG = function(size) {\n      var bytes = new Array(size);\n      crypto.getRandomValues(_rnds);\n\n      for (var c = 0 ; c < size; c++) {\n        bytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;\n      }\n      return bytes;\n    }\n  }\n\n  module.exports = whatwgRNG || mathRNG;\n\n}())\n//@ sourceURL=/node_modules/crypto-browserify/rng.js"));

require.define("/node_modules/delta-stream/node_modules/event-stream/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {}\n//@ sourceURL=/node_modules/delta-stream/node_modules/event-stream/package.json"));

require.define("/node_modules/delta-stream/node_modules/event-stream/index.js",Function(['require','module','exports','__dirname','__filename','process'],"//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\n\nvar Stream = require('stream').Stream\n  , es = exports\n  , through = require('through')\n  , from = require('from')\n  , duplex = require('duplexer')\n  , map = require('map-stream')\n  , pause = require('pause-stream')\n\nes.Stream = Stream //re-export Stream from core\nes.through = through\nes.from = from\nes.duplex = duplex\nes.map = map\nes.pause = pause\n\n// merge / concat\n//\n// combine multiple streams into a single stream.\n// will emit end only once\n\nes.concat = //actually this should be called concat\nes.merge = function (/*streams...*/) {\n  var toMerge = [].slice.call(arguments)\n  var stream = new Stream()\n  var endCount = 0\n  stream.writable = stream.readable = true\n\n  toMerge.forEach(function (e) {\n    e.pipe(stream, {end: false})\n    var ended = false\n    e.on('end', function () {\n      if(ended) return\n      ended = true\n      endCount ++\n      if(endCount == toMerge.length)\n        stream.emit('end') \n    })\n  })\n  stream.write = function (data) {\n    this.emit('data', data)\n  }\n  stream.destroy = function () {\n    merge.forEach(function (e) {\n      if(e.destroy) e.destroy()\n    })\n  }\n  return stream\n}\n\n\n// writable stream, collects all events into an array \n// and calls back when 'end' occurs\n// mainly I'm using this to test the other functions\n\nes.writeArray = function (done) {\n  if ('function' !== typeof done)\n    throw new Error('function writeArray (done): done must be function')\n\n  var a = new Stream ()\n    , array = [], isDone = false\n  a.write = function (l) {\n    array.push(l)\n  }\n  a.end = function () {\n    isDone = true\n    done(null, array)\n  }\n  a.writable = true\n  a.readable = false\n  a.destroy = function () {\n    a.writable = a.readable = false\n    if(isDone) return\n    done(new Error('destroyed before end'), array)\n  }\n  return a\n}\n\n//return a Stream that reads the properties of an object\n//respecting pause() and resume()\n\nes.readArray = function (array) {\n  var stream = new Stream()\n    , i = 0\n    , paused = false\n    , ended = false\n \n  stream.readable = true  \n  stream.writable = false\n \n  if(!Array.isArray(array))\n    throw new Error('event-stream.read expects an array')\n  \n  stream.resume = function () {\n    if(ended) return\n    paused = false\n    var l = array.length\n    while(i < l && !paused && !ended) {\n      stream.emit('data', array[i++])\n    }\n    if(i == l && !ended)\n      ended = true, stream.readable = false, stream.emit('end')\n  }\n  process.nextTick(stream.resume)\n  stream.pause = function () {\n     paused = true\n  }\n  stream.destroy = function () {\n    ended = true\n    stream.emit('close')\n  }\n  return stream\n}\n\n//\n// readable (asyncFunction)\n// return a stream that calls an async function while the stream is not paused.\n//\n// the function must take: (count, callback) {...\n//\n\nes.readable = function (func, continueOnError) {\n  var stream = new Stream()\n    , i = 0\n    , paused = false\n    , ended = false\n    , reading = false\n\n  stream.readable = true  \n  stream.writable = false\n \n  if('function' !== typeof func)\n    throw new Error('event-stream.readable expects async function')\n  \n  stream.on('end', function () { ended = true })\n  \n  function get (err, data) {\n    \n    if(err) {\n      stream.emit('error', err)\n      if(!continueOnError) stream.emit('end')\n    } else if (arguments.length > 1)\n      stream.emit('data', data)\n\n    process.nextTick(function () {\n      if(ended || paused || reading) return\n      try {\n        reading = true\n        func.call(stream, i++, function () {\n          reading = false\n          get.apply(null, arguments)\n        })\n      } catch (err) {\n        stream.emit('error', err)    \n      }\n    })\n  \n  }\n  stream.resume = function () {\n    paused = false\n    get()\n  }\n  process.nextTick(get)\n  stream.pause = function () {\n     paused = true\n  }\n  stream.destroy = function () {\n    stream.emit('end')\n    stream.emit('close')\n    ended = true\n  }\n  return stream\n}\n\n\n\n//\n// map sync\n//\n\nes.mapSync = function (sync) { \n  return es.through(function write(data) {\n    var mappedData = sync(data)\n    if (typeof mappedData !== 'undefined')\n      this.emit('data', mappedData)\n  })\n}\n\n//\n// log just print out what is coming through the stream, for debugging\n//\n\nes.log = function (name) {\n  return es.through(function (data) {\n    var args = [].slice.call(arguments)\n    if(name) console.error(name, data)\n    else     console.error(data)\n    this.emit('data', data)\n  })\n}\n\n//\n// combine multiple streams together so that they act as a single stream\n//\nes.pipeline = \nes.pipe = es.connect = function () {\n\n  var streams = [].slice.call(arguments)\n    , first = streams[0]\n    , last = streams[streams.length - 1]\n    , thepipe = es.duplex(first, last)\n\n  if(streams.length == 1)\n    return streams[0]\n  else if (!streams.length)\n    throw new Error('connect called with empty args')\n\n  //pipe all the streams together\n\n  function recurse (streams) {\n    if(streams.length < 2)\n      return\n    streams[0].pipe(streams[1])\n    recurse(streams.slice(1))  \n  }\n  \n  recurse(streams)\n \n  function onerror () {\n    var args = [].slice.call(arguments)\n    args.unshift('error')\n    thepipe.emit.apply(thepipe, args)\n  }\n  \n  streams.forEach(function (stream) {\n    stream.on('error', onerror)\n  })\n\n  return thepipe\n}\n\n//\n// child -- pipe through a child process\n//\n\nes.child = function (child) {\n\n  return es.duplex(child.stdin, child.stdout)\n\n}\n\nes.split = function (matcher) {\n  var soFar = ''\n  if (!matcher)\n    matcher = '\\n'\n\n  return es.through(function (buffer) { \n    var stream = this\n      , pieces = (soFar + buffer).split(matcher)\n    soFar = pieces.pop()\n\n    pieces.forEach(function (piece) {\n      stream.emit('data', piece)\n    })\n\n    return true\n  },\n  function () {\n    if(soFar)\n      this.emit('data', soFar)  \n    this.emit('end')\n  })\n}\n\n//\n// parse\n//\n// must be used after es.split() to ensure that each chunk represents a line\n// source.pipe(es.split()).pipe(es.parse())\n\nes.parse = function () { \n  return es.through(function (data) {\n    var obj\n    try {\n      if(data) //ignore empty lines\n        obj = JSON.parse(data.toString())\n    } catch (err) {\n      return console.error(err, 'attemping to parse:', data)\n    }\n    //ignore lines that where only whitespace.\n    if(obj !== undefined)\n      this.emit('data', obj)\n  })\n}\n//\n// stringify\n//\n\nes.stringify = function () { \n  var Buffer = require('buffer').Buffer\n  return es.mapSync(function (e){ \n    return JSON.stringify(Buffer.isBuffer(e) ? e.toString() : e) + '\\n'\n  }) \n}\n\n//\n// replace a string within a stream.\n//\n// warn: just concatenates the string and then does str.split().join(). \n// probably not optimal.\n// for smallish responses, who cares?\n// I need this for shadow-npm so it's only relatively small json files.\n\nes.replace = function (from, to) {\n  return es.pipeline(es.split(from), es.join(to))\n} \n\n//\n// join chunks with a joiner. just like Array#join\n// also accepts a callback that is passed the chunks appended together\n// this is still supported for legacy reasons.\n// \n\nes.join = function (str) {\n  \n  //legacy api\n  if('function' === typeof str)\n    return es.wait(str)\n\n  var first = true\n  return es.through(function (data) {\n    if(!first)\n      this.emit('data', str)\n    first = false\n    this.emit('data', data)\n    return true\n  })\n}\n\n\n//\n// wait. callback when 'end' is emitted, with all chunks appended as string.\n//\n\nes.wait = function (callback) {\n  var body = ''\n  return es.through(function (data) { body += data },\n    function () {\n      this.emit('data', body)\n      this.emit('end')\n      if(callback) callback(null, body)\n    })\n}\n\n//\n// helper to make your module into a unix pipe\n// simply add \n// \n// if(!module.parent)\n//  require('event-stream').pipable(asyncFunctionOrStreams)\n// \n// asyncFunctionOrStreams may be one or more Streams or if it is a function, \n// it will be automatically wrapped in es.map\n//\n// then pipe stuff into from the command line!\n// \n// curl registry.npmjs.org/event-stream | node hello-pipeable.js | grep whatever\n//\n// etc!\n//\n// also, start pipeable running as a server!\n//\n// > node hello-pipeable.js --port 44444\n// \n\nvar setup = function (args) {\n  return args.map(function (f) {\n    var x = f()\n      if('function' === typeof x)\n        return es.map(x)\n      return x\n    })\n}\n\nes.pipeable = function () {\n  console.error('warn: event-stream. I have decided that pipeable is a kitchen-sick and will remove soon if no objections')\n  console.error('please post an issue if you actually use this. -- dominictarr')\n  throw new Error('[EVENT-STREAM] es.pipeable is deprecated')\n}\n\n//@ sourceURL=/node_modules/delta-stream/node_modules/event-stream/index.js"));

require.define("/node_modules/delta-stream/node_modules/event-stream/node_modules/through/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/delta-stream/node_modules/event-stream/node_modules/through/package.json"));

require.define("/node_modules/delta-stream/node_modules/event-stream/node_modules/through/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end) {\n  write = write || function (data) { this.emit('data', data) }\n  end = end || function () { this.emit('end') }\n\n  var ended = false, destroyed = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false  \n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here. \n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  stream.end = function (data) {\n    if(ended) return \n    //this breaks, because pipe doesn't check writable before calling end.\n    //throw new Error('cannot call end twice')\n    ended = true\n    if(arguments.length) stream.write(data)\n    this.writable = false\n    end.call(this)\n    if(!this.readable)\n      this.destroy()\n  }\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    stream.writable = stream.readable = false\n    stream.emit('close')\n  }\n  stream.pause = function () {\n    stream.paused = true\n  }\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n      stream.emit('drain')\n    }\n  }\n  return stream\n}\n\n\n//@ sourceURL=/node_modules/delta-stream/node_modules/event-stream/node_modules/through/index.js"));

require.define("/node_modules/delta-stream/node_modules/event-stream/node_modules/from/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/delta-stream/node_modules/event-stream/node_modules/from/package.json"));

require.define("/node_modules/delta-stream/node_modules/event-stream/node_modules/from/index.js",Function(['require','module','exports','__dirname','__filename','process'],"\nvar Stream = require('stream')\n\n// from\n//\n// a stream that reads from an source.\n// source may be an array, or a function.\n// from handles pause behaviour for you.\n\nmodule.exports =\nfunction from (source) {\n  if(Array.isArray(source))\n    return from (function (i) {\n      if(source.length)\n        this.emit('data', source.shift())\n      else\n        this.emit('end')\n      return true\n    })\n\n  var s = new Stream(), i = 0, ended = false, started = false\n  s.readable = true\n  s.writable = false\n  s.paused = false\n  s.pause = function () {\n    started = true\n    s.paused = true\n  }\n  function next () {\n    var n = 0, r = false\n    if(ended) return\n    while(!ended && !s.paused && source.call(s, i++, function () {\n      if(!n++ && !s.ended && !s.paused)\n          next()\n    }))\n      ;\n  }\n  s.resume = function () {\n    started = true\n    s.paused = false\n    next()\n  }\n  s.on('end', function () {\n    ended = true\n    s.readable = false\n    process.nextTick(s.destroy)\n  })\n  s.destroy = function () {\n    ended = true\n    s.emit('close') \n  }\n  /*\n    by default, the stream will start emitting at nextTick\n    if you want, you can pause it, after pipeing.\n    you can also resume before next tick, and that will also\n    work.\n  */\n  process.nextTick(function () {\n    if(!started) s.resume()\n  })\n  return s\n}\n\n//@ sourceURL=/node_modules/delta-stream/node_modules/event-stream/node_modules/from/index.js"));

require.define("/node_modules/delta-stream/node_modules/event-stream/node_modules/duplexer/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/delta-stream/node_modules/event-stream/node_modules/duplexer/package.json"));

require.define("/node_modules/delta-stream/node_modules/event-stream/node_modules/duplexer/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Stream = require(\"stream\")\n    , writeMethods = [\"write\", \"end\", \"destroy\"]\n    , readMethods = [\"resume\", \"pause\"]\n    , readEvents = [\"data\", \"close\"]\n    , slice = Array.prototype.slice\n\nmodule.exports = duplex\n\nfunction duplex(writer, reader) {\n    var stream = new Stream()\n        , ended = false\n\n    Object.defineProperties(stream, {\n        writable: {\n            get: getWritable\n        }\n        , readable: {\n            get: getReadable\n        }\n    })\n\n    writeMethods.forEach(proxyWriter)\n\n    readMethods.forEach(proxyReader)\n\n    readEvents.forEach(proxyStream)\n\n    reader.on(\"end\", handleEnd)\n\n    writer.on(\"error\", reemit)\n    reader.on(\"error\", reemit)\n\n    return stream\n\n    function getWritable() {\n        return writer.writable\n    }\n\n    function getReadable() {\n        return reader.readable\n    }\n\n    function proxyWriter(methodName) {\n        stream[methodName] = method\n\n        function method() {\n            return writer[methodName].apply(writer, arguments)\n        }\n    }\n\n    function proxyReader(methodName) {\n        stream[methodName] = method\n\n        function method() {\n            stream.emit(methodName)\n            var func = reader[methodName]\n            if (func) {\n                return func.apply(reader, arguments)\n            }\n            reader.emit(methodName)\n        }\n    }\n\n    function proxyStream(methodName) {\n        reader.on(methodName, reemit)\n\n        function reemit() {\n            var args = slice.call(arguments)\n            args.unshift(methodName)\n            stream.emit.apply(stream, args)\n        }\n    }\n\n    function handleEnd() {\n        if (ended) {\n            return\n        }\n        ended = true\n        var args = slice.call(arguments)\n        args.unshift(\"end\")\n        stream.emit.apply(stream, args)\n    }\n\n    function reemit(err) {\n        stream.emit(\"error\", err)\n    }\n}\n//@ sourceURL=/node_modules/delta-stream/node_modules/event-stream/node_modules/duplexer/index.js"));

require.define("/node_modules/delta-stream/node_modules/event-stream/node_modules/map-stream/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {}\n//@ sourceURL=/node_modules/delta-stream/node_modules/event-stream/node_modules/map-stream/package.json"));

require.define("/node_modules/delta-stream/node_modules/event-stream/node_modules/map-stream/index.js",Function(['require','module','exports','__dirname','__filename','process'],"//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\n\nvar Stream = require('stream').Stream\n\n\n//create an event stream and apply function to each .write\n//emitting each response as data\n//unless it's an empty callback\n\nmodule.exports = function (mapper) {\n  var stream = new Stream()\n    , inputs = 0\n    , outputs = 0\n    , ended = false\n    , paused = false\n    , destroyed = false\n\n  stream.writable = true\n  stream.readable = true\n   \n  stream.write = function () {\n    if(ended) throw new Error('map stream is not writable')\n    inputs ++\n    var args = [].slice.call(arguments)\n      , r\n      , inNext = false \n    //pipe only allows one argument. so, do not \n    function next (err) {\n      if(destroyed) return\n      inNext = true\n      outputs ++\n      var args = [].slice.call(arguments)\n      if(err) {\n        args.unshift('error')\n        return inNext = false, stream.emit.apply(stream, args)\n      }\n      args.shift() //drop err\n      if (args.length) {\n        args.unshift('data')\n        r = stream.emit.apply(stream, args)\n      }\n      if(inputs == outputs) {\n        if(paused) paused = false, stream.emit('drain') //written all the incoming events\n        if(ended) end()\n      }\n      inNext = false\n    }\n    args.push(next)\n    \n    try {\n      //catch sync errors and handle them like async errors\n      var written = mapper.apply(null, args)\n      paused = (written === false)\n      return !paused\n    } catch (err) {\n      //if the callback has been called syncronously, and the error\n      //has occured in an listener, throw it again.\n      if(inNext)\n        throw err\n      next(err)\n      return !paused\n    }\n  }\n\n  function end (data) {\n    //if end was called with args, write it, \n    ended = true //write will emit 'end' if ended is true\n    stream.writable = false\n    if(data !== undefined)\n      return stream.write(data)\n    else if (inputs == outputs) //wait for processing \n      stream.readable = false, stream.emit('end'), stream.destroy() \n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    end()\n  }\n\n  stream.destroy = function () {\n    ended = destroyed = true\n    stream.writable = stream.readable = paused = false\n    process.nextTick(function () {\n      stream.emit('close')\n    })\n  }\n  stream.pause = function () {\n    paused = true\n  }\n\n  stream.resume = function () {\n    paused = false\n  }\n\n  return stream\n}\n\n\n\n\n\n//@ sourceURL=/node_modules/delta-stream/node_modules/event-stream/node_modules/map-stream/index.js"));

require.define("/node_modules/delta-stream/node_modules/event-stream/node_modules/pause-stream/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/delta-stream/node_modules/event-stream/node_modules/pause-stream/package.json"));

require.define("/node_modules/delta-stream/node_modules/event-stream/node_modules/pause-stream/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Stream = require('stream')\n\n/*\n  was gonna use through for this,\n  but it does not match quite right,\n  because you need a seperate pause\n  mechanism for the readable and writable\n  sides.\n*/\n\nmodule.exports = function () {\n  var buffer = [], ended = false, destroyed = false\n  var stream = new Stream() \n  stream.writable = stream.readable = true\n  stream.paused = false \n  \n  stream.write = function (data) {\n    if(!this.paused)\n      this.emit('data', data)\n    else \n      buffer.push(data)\n    return !(this.paused || buffer.length)\n  }\n  function onEnd () {\n    stream.readable = false\n    stream.emit('end')\n    process.nextTick(stream.destroy.bind(stream))\n  }\n  stream.end = function (data) {\n    if(data) this.write(data)\n    this.ended = true\n    this.writable = false\n    if(!(this.paused || buffer.length))\n      return onEnd()\n    else\n      this.once('drain', onEnd)\n    this.drain()\n  }\n\n  stream.drain = function () {\n    while(!this.paused && buffer.length)\n      this.emit('data', buffer.shift())\n    //if the buffer has emptied. emit drain.\n    if(!buffer.length && !this.paused)\n      this.emit('drain')\n  }\n\n  stream.resume = function () {\n    //this is where I need pauseRead, and pauseWrite.\n    //here the reading side is unpaused,\n    //but the writing side may still be paused.\n    //the whole buffer might not empity at once.\n    //it might pause again.\n    //the stream should never emit data inbetween pause()...resume()\n    //and write should return !buffer.length\n\n    this.paused = false\n//    process.nextTick(this.drain.bind(this)) //will emit drain if buffer empties.\n    this.drain()\n    return this\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = ended = true     \n    buffer.length = 0\n    this.emit('close')\n  }\n\n  stream.pause = function () {\n    stream.paused = true\n    return this\n  }\n \n  return stream\n}\n\n//@ sourceURL=/node_modules/delta-stream/node_modules/event-stream/node_modules/pause-stream/index.js"));

require.define("buffer",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = require(\"buffer-browserify\")\n//@ sourceURL=buffer"));

require.define("/node_modules/buffer-browserify/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index.js\",\"browserify\":\"index.js\"}\n//@ sourceURL=/node_modules/buffer-browserify/package.json"));

require.define("/node_modules/buffer-browserify/index.js",Function(['require','module','exports','__dirname','__filename','process'],"function SlowBuffer (size) {\n    this.length = size;\n};\n\nvar assert = require('assert');\n\nexports.INSPECT_MAX_BYTES = 50;\n\n\nfunction toHex(n) {\n  if (n < 16) return '0' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require(\"base64-js\").toByteArray(str);\n}\n\nSlowBuffer.byteLength = function (str, encoding) {\n  switch (encoding || \"utf8\") {\n    case 'hex':\n      return str.length / 2;\n\n    case 'utf8':\n    case 'utf-8':\n      return utf8ToBytes(str).length;\n\n    case 'ascii':\n      return str.length;\n\n    case 'base64':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nSlowBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require(\"base64-js\").fromByteArray(bytes);\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\nSlowBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = \"\";\n  var tmp = \"\";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = \"\";\n    } else\n      tmp += \"%\" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nSlowBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = \"\";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nSlowBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...';\n      break;\n    }\n  }\n  return '<SlowBuffer ' + out.join(' ') + '>';\n};\n\n\nSlowBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nSlowBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || 'utf8').toLowerCase();\n  start = +start || 0;\n  if (typeof end == 'undefined') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return '';\n  }\n\n  switch (encoding) {\n    case 'hex':\n      return this.hexSlice(start, end);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.utf8Slice(start, end);\n\n    case 'ascii':\n      return this.asciiSlice(start, end);\n\n    case 'binary':\n      return this.binarySlice(start, end);\n\n    case 'base64':\n      return this.base64Slice(start, end);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\nSlowBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error('Invalid hex string');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error('Invalid hex string');\n    this[offset + i] = byte;\n  }\n  SlowBuffer._charsWritten = i * 2;\n  return i;\n};\n\n\nSlowBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  switch (encoding) {\n    case 'hex':\n      return this.hexWrite(string, offset, length);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.utf8Write(string, offset, length);\n\n    case 'ascii':\n      return this.asciiWrite(string, offset, length);\n\n    case 'binary':\n      return this.binaryWrite(string, offset, length);\n\n    case 'base64':\n      return this.base64Write(string, offset, length);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\n// slice(start, end)\nSlowBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error('oob');\n  }\n  if (start > end) {\n    throw new Error('oob');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it's fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\n\n// Buffer\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === 'number') {\n    this.length = coerce(encoding);\n    this.parent = subject;\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case 'number':\n        this.length = coerce(subject);\n        break;\n\n      case 'string':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case 'object': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error('First argument needs to be a number, ' +\n                        'array or string.');\n    }\n\n    if (this.length > Buffer.poolSize) {\n      // Big buffer, just alloc one.\n      this.parent = new SlowBuffer(this.length);\n      this.offset = 0;\n\n    } else {\n      // Small buffer.\n      if (!pool || pool.length - pool.used < this.length) allocPool();\n      this.parent = pool;\n      this.offset = pool.used;\n      pool.used += this.length;\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        this.parent[i + this.offset] = subject[i];\n      }\n    } else if (type == 'string') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    }\n  }\n\n}\n\nfunction isArrayIsh(subject) {\n  return Array.isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === 'object' &&\n         typeof subject.length === 'number';\n}\n\nexports.SlowBuffer = SlowBuffer;\nexports.Buffer = Buffer;\n\nBuffer.poolSize = 8 * 1024;\nvar pool;\n\nfunction allocPool() {\n  pool = new SlowBuffer(Buffer.poolSize);\n  pool.used = 0;\n}\n\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof SlowBuffer;\n};\n\n\n// Inspect\nBuffer.prototype.inspect = function inspect() {\n  var out = [],\n      len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this.parent[i + this.offset]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...';\n      break;\n    }\n  }\n\n  return '<Buffer ' + out.join(' ') + '>';\n};\n\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error('oob');\n  return this.parent[this.offset + i];\n};\n\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error('oob');\n  return this.parent[this.offset + i] = v;\n};\n\n\n// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  var ret;\n  switch (encoding) {\n    case 'hex':\n      ret = this.parent.hexWrite(string, this.offset + offset, length);\n      break;\n\n    case 'utf8':\n    case 'utf-8':\n      ret = this.parent.utf8Write(string, this.offset + offset, length);\n      break;\n\n    case 'ascii':\n      ret = this.parent.asciiWrite(string, this.offset + offset, length);\n      break;\n\n    case 'binary':\n      ret = this.parent.binaryWrite(string, this.offset + offset, length);\n      break;\n\n    case 'base64':\n      // Warning: maxLength not taken into account in base64Write\n      ret = this.parent.base64Write(string, this.offset + offset, length);\n      break;\n\n    case 'ucs2':\n    case 'ucs-2':\n      ret = this.parent.ucs2Write(string, this.offset + offset, length);\n      break;\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n\n  Buffer._charsWritten = SlowBuffer._charsWritten;\n\n  return ret;\n};\n\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  if (typeof start == 'undefined' || start < 0) {\n    start = 0;\n  } else if (start > this.length) {\n    start = this.length;\n  }\n\n  if (typeof end == 'undefined' || end > this.length) {\n    end = this.length;\n  } else if (end < 0) {\n    end = 0;\n  }\n\n  start = start + this.offset;\n  end = end + this.offset;\n\n  switch (encoding) {\n    case 'hex':\n      return this.parent.hexSlice(start, end);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.parent.utf8Slice(start, end);\n\n    case 'ascii':\n      return this.parent.asciiSlice(start, end);\n\n    case 'binary':\n      return this.parent.binarySlice(start, end);\n\n    case 'base64':\n      return this.parent.base64Slice(start, end);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.parent.ucs2Slice(start, end);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\n// byteLength\nBuffer.byteLength = SlowBuffer.byteLength;\n\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === 'string') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === 'number') || isNaN(value)) {\n    throw new Error('value is not a number');\n  }\n\n  if (end < start) throw new Error('end < start');\n\n  // Fill 0 bytes; we're done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error('start out of bounds');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error('end out of bounds');\n  }\n\n  return this.parent.fill(value,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  end || (end = this.length);\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error('sourceEnd < sourceStart');\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error('targetStart out of bounds');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error('sourceStart out of bounds');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error('sourceEnd out of bounds');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  return this.parent.copy(target.parent,\n                          target_start + target.offset,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n  if (end > this.length) throw new Error('oob');\n  if (start > end) throw new Error('oob');\n\n  return new Buffer(this.parent, end - start, +start + this.offset);\n};\n\n\n// Legacy methods for backwards compatibility.\n\nBuffer.prototype.utf8Slice = function(start, end) {\n  return this.toString('utf8', start, end);\n};\n\nBuffer.prototype.binarySlice = function(start, end) {\n  return this.toString('binary', start, end);\n};\n\nBuffer.prototype.asciiSlice = function(start, end) {\n  return this.toString('ascii', start, end);\n};\n\nBuffer.prototype.utf8Write = function(string, offset) {\n  return this.write(string, offset, 'utf8');\n};\n\nBuffer.prototype.binaryWrite = function(string, offset) {\n  return this.write(string, offset, 'binary');\n};\n\nBuffer.prototype.asciiWrite = function(string, offset) {\n  return this.write(string, offset, 'ascii');\n};\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return buffer[offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (isBigEndian) {\n    val = buffer[offset] << 8;\n    val |= buffer[offset + 1];\n  } else {\n    val = buffer[offset];\n    val |= buffer[offset + 1] << 8;\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (isBigEndian) {\n    val = buffer[offset + 1] << 16;\n    val |= buffer[offset + 2] << 8;\n    val |= buffer[offset + 3];\n    val = val + (buffer[offset] << 24 >>> 0);\n  } else {\n    val = buffer[offset + 2] << 16;\n    val |= buffer[offset + 1] << 8;\n    val |= buffer[offset];\n    val = val + (buffer[offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two's complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two's complement value is\n * positive, then we're done, as it's equivalent to the unsigned representation.\n *\n * Now if the number is positive, you're pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren't quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two's\n * complement. (Though it doesn't quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn't quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that's not quite right. But wait, according to\n * Javascript that's perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we've input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we're going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I'm glad we don't support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn't make sense for 8-bit numbers\n * (really it isn't necessary for them). However, when you get 16-bit numbers,\n * you do. Let's go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  neg = buffer[offset] & 0x80;\n  if (!neg) {\n    return (buffer[offset]);\n  }\n\n  return ((0xff - buffer[offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset + 7 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value >= 0,\n      'specified a negative value for writing an unsigned value');\n\n  assert.ok(value <= max, 'value is larger than maximum value for type');\n\n  assert.ok(Math.floor(value) === value, 'value has a fractional component');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xff);\n  }\n\n  buffer[offset] = value;\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xffff);\n  }\n\n  if (isBigEndian) {\n    buffer[offset] = (value & 0xff00) >>> 8;\n    buffer[offset + 1] = value & 0x00ff;\n  } else {\n    buffer[offset + 1] = (value & 0xff00) >>> 8;\n    buffer[offset] = value & 0x00ff;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  if (isBigEndian) {\n    buffer[offset] = (value >>> 24) & 0xff;\n    buffer[offset + 1] = (value >>> 16) & 0xff;\n    buffer[offset + 2] = (value >>> 8) & 0xff;\n    buffer[offset + 3] = value & 0xff;\n  } else {\n    buffer[offset + 3] = (value >>> 24) & 0xff;\n    buffer[offset + 2] = (value >>> 16) & 0xff;\n    buffer[offset + 1] = (value >>> 8) & 0xff;\n    buffer[offset] = value & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we're going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we're in\n * slightly better shape. Unfortunately, we really can't do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren't treated as a signed number. Ultimately a bad thing.\n *\n * What we're going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we're going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value <= max, 'value larger than maximum allowed value');\n\n  assert.ok(value >= min, 'value smaller than minimum allowed value');\n\n  assert.ok(Math.floor(value) === value, 'value has a fractional component');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value <= max, 'value larger than maximum allowed value');\n\n  assert.ok(value >= min, 'value smaller than minimum allowed value');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 7 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\nSlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;\nSlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;\nSlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;\nSlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;\nSlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;\nSlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;\nSlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;\nSlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;\nSlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;\nSlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;\nSlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;\nSlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;\nSlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;\nSlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;\nSlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;\nSlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;\nSlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;\nSlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;\nSlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;\nSlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;\nSlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;\nSlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;\nSlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;\nSlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;\nSlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;\nSlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;\nSlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;\nSlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;\n\n//@ sourceURL=/node_modules/buffer-browserify/index.js"));

require.define("assert",Function(['require','module','exports','__dirname','__filename','process'],"// UTILITY\nvar util = require('util');\nvar Buffer = require(\"buffer\").Buffer;\nvar pSlice = Array.prototype.slice;\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.message = options.message;\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n};\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (value === undefined) {\n    return '' + value;\n  }\n  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (typeof value === 'function' || value instanceof RegExp) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (typeof s == 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nassert.AssertionError.prototype.toString = function() {\n  if (this.message) {\n    return [this.name + ':', this.message].join(' ');\n  } else {\n    return [\n      this.name + ':',\n      truncate(JSON.stringify(this.actual, replacer), 128),\n      this.operator,\n      truncate(JSON.stringify(this.expected, replacer), 128)\n    ].join(' ');\n  }\n};\n\n// assert.AssertionError instanceof Error\n\nassert.AssertionError.__proto__ = Error.prototype;\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!!!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (typeof actual != 'object' && typeof expected != 'object') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = Object.keys(a),\n        kb = Object.keys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (expected instanceof RegExp) {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail('Missing expected exception' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail('Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\n//@ sourceURL=assert"));

require.define("/node_modules/buffer-browserify/node_modules/base64-js/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"lib/b64.js\"}\n//@ sourceURL=/node_modules/buffer-browserify/node_modules/base64-js/package.json"));

require.define("/node_modules/buffer-browserify/node_modules/base64-js/lib/b64.js",Function(['require','module','exports','__dirname','__filename','process'],"(function (exports) {\n\t'use strict';\n\n\tvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow 'Invalid string. Length must be a multiple of 4';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf('=');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += '==';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += '=';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n//@ sourceURL=/node_modules/buffer-browserify/node_modules/base64-js/lib/b64.js"));

require.define("/node_modules/buffer-browserify/buffer_ieee754.js",Function(['require','module','exports','__dirname','__filename','process'],"exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n//@ sourceURL=/node_modules/buffer-browserify/buffer_ieee754.js"));

require.define("/node_modules/delta-stream/node_modules/through/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/delta-stream/node_modules/through/package.json"));

require.define("/node_modules/delta-stream/node_modules/through/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end) {\n  write = write || function (data) { this.emit('data', data) }\n  end = end || function () { this.emit('end') }\n\n  var ended = false, destroyed = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false  \n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here. \n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  stream.end = function (data) {\n    if(ended) return \n    //this breaks, because pipe doesn't check writable before calling end.\n    //throw new Error('cannot call end twice')\n    ended = true\n    if(arguments.length) stream.write(data)\n    this.writable = false\n    end.call(this)\n    if(!this.readable)\n      this.destroy()\n  }\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    stream.writable = stream.readable = false\n    stream.emit('close')\n  }\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    stream.emit('pause')\n  }\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n      stream.emit('drain')\n    }\n  }\n  return stream\n}\n\n\n//@ sourceURL=/node_modules/delta-stream/node_modules/through/index.js"));

require.define("/node_modules/delta-stream/node_modules/ap/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"./index.js\"}\n//@ sourceURL=/node_modules/delta-stream/node_modules/ap/package.json"));

require.define("/node_modules/delta-stream/node_modules/ap/index.js",Function(['require','module','exports','__dirname','__filename','process'],"exports = module.exports = ap;\nfunction ap (args, fn) {\n    return function () {\n        return fn.apply(this, args.concat.apply(args, arguments));\n    };\n}\n\nexports.pa = pa;\nfunction pa (args, fn) {\n    return function () {\n        return fn.apply(this, [].slice.call(arguments).concat(args));\n    };\n}\n\nexports.apa = apa;\nfunction apa (left, right, fn) {\n    return function () {\n        return fn.apply(this,\n            left.concat.apply(left, arguments).concat(right)\n        );\n    };\n}\n\nexports.partial = partial;\nfunction partial (fn) {\n    var args = [].slice.call(arguments, 1);\n    return ap(args, fn);\n}\n\nexports.partialRight = partialRight;\nfunction partialRight (fn) {\n    var args = [].slice.call(arguments, 1);\n    return pa(args, fn);\n}\n\nexports.curry = curry;\nfunction curry (fn) {\n    return partial(partial, fn);\n}\n\nexports.curryRight = function curryRight (fn) {\n    return partial(partialRight, fn);\n}\n\n//@ sourceURL=/node_modules/delta-stream/node_modules/ap/index.js"));

require.define("/node_modules/delta-stream/interfaces/observable.js",Function(['require','module','exports','__dirname','__filename','process'],"var DeltaStream = require(\"../index\")\n    , uuid = require(\"node-uuid\")\n    , EventEmitter = require(\"events\").EventEmitter\n\nObservable.from = createStream\n\nmodule.exports = Observable\n\nfunction Observable(stream) {\n    var observable = new EventEmitter()\n        , state = {}\n\n    observable.set = set\n    observable.get = get\n    observable.toJSON = toJSON\n    observable.createStream = createStream\n    observable.sync = sync\n\n    if (stream) {\n        observable.id = stream.id\n        bind(observable, stream)\n    } else {\n        observable.id = uuid()\n    }\n\n    return observable\n\n    function set(key, value, source) {\n        var changes = {}\n\n        state[key] = value\n        changes[key] = value\n\n        observable.emit(\"change\", changes, source)\n        observable.emit(\"change:\" + key, value)\n    }\n\n    function get(key) {\n        if (key) {\n            return state[key]\n        }\n\n        return state\n    }\n\n    function toJSON() {\n        return state\n    }\n\n    function sync(other) {\n        Object.keys(state).forEach(callSet)\n\n        function callSet(key) {\n            other.set(key, state[key])\n        }\n    }\n\n}\n\nfunction createStream(observable) {\n    var stream = DeltaStream(observable.id)\n\n    bind(observable, stream)\n\n    return stream\n}\n\nfunction bind(observable, stream) {\n    observable.on(\"change\", onchange)\n\n    stream.other.on(\"data\", ondata)\n\n    function ondata(data) {\n        var changes = data[0]\n            , source = data[2]\n\n        Object.keys(changes).forEach(applyChanges)\n\n        function applyChanges(key) {\n            var value = changes[key]\n            observable.set(key, value, source)\n        }\n    }\n\n    function onchange(changes, source) {\n        var ts = Date.now()\n            , data = [changes, ts, source]\n\n        stream.other.write(data)\n    }\n}\n//@ sourceURL=/node_modules/delta-stream/interfaces/observable.js"));

require.define("/node_modules/arrow-keys/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/arrow-keys/package.json"));

require.define("/node_modules/arrow-keys/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var through = require(\"through\")\n    , uuid = require(\"node-uuid\")\n    , KEYS = {\n        \"37\": \"left\"\n        , \"38\": \"up\"\n        , \"39\": \"right\"\n        , \"40\": \"down\"\n    }\n    , down = {}\n\nwindow.addEventListener(\"keyup\", onup)\nwindow.addEventListener(\"keydown\", ondown)\n\nmodule.exports = ArrowKeys\n\nfunction ArrowKeys(fps) {\n    var stream = through()\n        , id = uuid()\n\n    fps = fps || 60\n\n    var timeOffset = 1000.0 / fps\n\n    setTimeout(move, timeOffset)\n    \n    return stream\n\n    function move() {\n        var changes = getChanges()\n\n        if (changes) {\n            stream.write([changes, Date.now(), id])\n        }\n\n        setTimeout(move, timeOffset)\n    }\n}\n\nfunction ondown(event) {\n    var key = KEYS[event.which]\n    down[key] = true\n}\n\nfunction onup(event) {\n    var key = KEYS[event.which]\n    down[key] = false\n}\n\nfunction getChanges() {\n    var x, y\n    if (down.up) {\n        y = -1\n    } else if (down.down) {\n        y = 1\n    }\n\n    if (down.left) {\n        x = -1\n    } else if (down.right) {\n        x = 1\n    }\n\n    if (!x && !y) {\n        return null\n    }\n\n    return {\n        x: x\n        , y: y\n    }\n}\n//@ sourceURL=/node_modules/arrow-keys/index.js"));

require.define("/node_modules/node-uuid/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"./uuid.js\"}\n//@ sourceURL=/node_modules/node-uuid/package.json"));

require.define("/node_modules/node-uuid/uuid.js",Function(['require','module','exports','__dirname','__filename','process'],"//     node-uuid/uuid.js\n//\n//     Copyright (c) 2010 Robert Kieffer\n//     Dual licensed under the MIT and GPL licenses.\n//     Documentation and details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  // Unique ID creation requires a high quality random # generator, but\n  // Math.random() does not guarantee \"cryptographic quality\".  So we feature\n  // detect for more robust APIs, normalizing each method to return 128-bits\n  // (16 bytes) of random data.\n  var mathRNG, nodeRNG, whatwgRNG;\n\n  // Math.random()-based RNG.  All platforms, very fast, unknown quality\n  var _rndBytes = new Array(16);\n  mathRNG = function() {\n    var r, b = _rndBytes, i = 0;\n\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      b[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return b;\n  }\n\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // WebKit only (currently), moderately fast, high quality\n  if (_global.crypto && crypto.getRandomValues) {\n    var _rnds = new Uint32Array(4);\n    whatwgRNG = function() {\n      crypto.getRandomValues(_rnds);\n\n      for (var c = 0 ; c < 16; c++) {\n        _rndBytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;\n      }\n      return _rndBytes;\n    }\n  }\n\n  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html\n  // Node.js only, moderately fast, high quality\n  try {\n    var _rb = require('crypto').randomBytes;\n    nodeRNG = _rb && function() {\n      return _rb(16);\n    };\n  } catch (e) {}\n\n  // Select RNG with best quality\n  var _rng = nodeRNG || whatwgRNG || mathRNG;\n\n  // Buffer class to use\n  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;\n\n  // Maps for number <-> hex string conversion\n  var _byteToHex = [];\n  var _hexToByte = {};\n  for (var i = 0; i < 256; i++) {\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    _hexToByte[_byteToHex[i]] = i;\n  }\n\n  // **`parse()` - Parse a UUID into it's component bytes**\n  function parse(s, buf, offset) {\n    var i = (buf && offset) || 0, ii = 0;\n\n    buf = buf || [];\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(byte) {\n      if (ii < 16) { // Don't overflow!\n        buf[i + ii++] = _hexToByte[byte];\n      }\n    });\n\n    // Zero out remaining bytes if string was short\n    while (ii < 16) {\n      buf[i + ii++] = 0;\n    }\n\n    return buf;\n  }\n\n  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n  function unparse(buf, offset) {\n    var i = offset || 0, bth = _byteToHex;\n    return  bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]];\n  }\n\n  // **`v1()` - Generate time-based UUID**\n  //\n  // Inspired by https://github.com/LiosK/UUID.js\n  // and http://docs.python.org/library/uuid.html\n\n  // random #'s we need to init node and clockseq\n  var _seedBytes = _rng();\n\n  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n  var _nodeId = [\n    _seedBytes[0] | 0x01,\n    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n  ];\n\n  // Per 4.2.2, randomize (14 bit) clockseq\n  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n  // Previous uuid creation time\n  var _lastMSecs = 0, _lastNSecs = 0;\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n\n    options = options || {};\n\n    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;\n\n    // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n    var msecs = options.msecs != null ? options.msecs : new Date().getTime();\n\n    // Per 4.2.1.2, use count of uuid's generated during the current clock\n    // cycle to simulate higher resolution clock\n    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;\n\n    // Time since last uuid creation (in msecs)\n    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n    // Per 4.2.1.2, Bump clockseq on clock regression\n    if (dt < 0 && options.clockseq == null) {\n      clockseq = clockseq + 1 & 0x3fff;\n    }\n\n    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n    // time interval\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {\n      nsecs = 0;\n    }\n\n    // Per 4.2.1.2 Throw error if too many uuids are requested\n    if (nsecs >= 10000) {\n      throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n    }\n\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n\n    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n    msecs += 12219292800000;\n\n    // `time_low`\n    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    b[i++] = tl >>> 24 & 0xff;\n    b[i++] = tl >>> 16 & 0xff;\n    b[i++] = tl >>> 8 & 0xff;\n    b[i++] = tl & 0xff;\n\n    // `time_mid`\n    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n    b[i++] = tmh >>> 8 & 0xff;\n    b[i++] = tmh & 0xff;\n\n    // `time_high_and_version`\n    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n    b[i++] = tmh >>> 16 & 0xff;\n\n    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n    b[i++] = clockseq >>> 8 | 0x80;\n\n    // `clock_seq_low`\n    b[i++] = clockseq & 0xff;\n\n    // `node`\n    var node = options.node || _nodeId;\n    for (var n = 0; n < 6; n++) {\n      b[i + n] = node[n];\n    }\n\n    return buf ? buf : unparse(b);\n  }\n\n  // **`v4()` - Generate random UUID**\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v4(options, buf, offset) {\n    // Deprecated - 'format' argument, as supported in v1.2\n    var i = buf && offset || 0;\n\n    if (typeof(options) == 'string') {\n      buf = options == 'binary' ? new BufferClass(16) : null;\n      options = null;\n    }\n    options = options || {};\n\n    var rnds = options.random || (options.rng || _rng)();\n\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n    // Copy bytes to buffer, if provided\n    if (buf) {\n      for (var ii = 0; ii < 16; ii++) {\n        buf[i + ii] = rnds[ii];\n      }\n    }\n\n    return buf || unparse(rnds);\n  }\n\n  // Export public API\n  var uuid = v4;\n  uuid.v1 = v1;\n  uuid.v4 = v4;\n  uuid.parse = parse;\n  uuid.unparse = unparse;\n  uuid.BufferClass = BufferClass;\n\n  // Export RNG options\n  uuid.mathRNG = mathRNG;\n  uuid.nodeRNG = nodeRNG;\n  uuid.whatwgRNG = whatwgRNG;\n\n  if (typeof(module) != 'undefined') {\n    // Play nice with node.js\n    module.exports = uuid;\n  } else {\n    // Play nice with browsers\n    var _previousRoot = _global.uuid;\n\n    // **`noConflict()` - (browser only) to reset global 'uuid' var**\n    uuid.noConflict = function() {\n      _global.uuid = _previousRoot;\n      return uuid;\n    }\n    _global.uuid = uuid;\n  }\n}());\n\n//@ sourceURL=/node_modules/node-uuid/uuid.js"));

require.define("/node_modules/duplexer/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/duplexer/package.json"));

require.define("/node_modules/duplexer/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Stream = require(\"stream\")\n    , writeMethods = [\"write\", \"end\", \"destroy\"]\n    , readMethods = [\"resume\", \"pause\"]\n    , readEvents = [\"data\", \"close\"]\n    , slice = Array.prototype.slice\n\nmodule.exports = duplex\n\nfunction duplex(writer, reader) {\n    var stream = new Stream()\n        , ended = false\n\n    Object.defineProperties(stream, {\n        writable: {\n            get: getWritable\n        }\n        , readable: {\n            get: getReadable\n        }\n    })\n\n    writeMethods.forEach(proxyWriter)\n\n    readMethods.forEach(proxyReader)\n\n    readEvents.forEach(proxyStream)\n\n    reader.on(\"end\", handleEnd)\n\n    writer.on(\"error\", reemit)\n    reader.on(\"error\", reemit)\n\n    return stream\n\n    function getWritable() {\n        return writer.writable\n    }\n\n    function getReadable() {\n        return reader.readable\n    }\n\n    function proxyWriter(methodName) {\n        stream[methodName] = method\n\n        function method() {\n            return writer[methodName].apply(writer, arguments)\n        }\n    }\n\n    function proxyReader(methodName) {\n        stream[methodName] = method\n\n        function method() {\n            stream.emit(methodName)\n            var func = reader[methodName]\n            if (func) {\n                return func.apply(reader, arguments)\n            }\n            reader.emit(methodName)\n        }\n    }\n\n    function proxyStream(methodName) {\n        reader.on(methodName, reemit)\n\n        function reemit() {\n            var args = slice.call(arguments)\n            args.unshift(methodName)\n            stream.emit.apply(stream, args)\n        }\n    }\n\n    function handleEnd() {\n        if (ended) {\n            return\n        }\n        ended = true\n        var args = slice.call(arguments)\n        args.unshift(\"end\")\n        stream.emit.apply(stream, args)\n    }\n\n    function reemit(err) {\n        stream.emit(\"error\", err)\n    }\n}\n//@ sourceURL=/node_modules/duplexer/index.js"));

require.define("/levels/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Wall = require(\"../wall\")\n    , SIZE = 20\n    , tileTypes = {\n        \"E\": noop\n        , \"W\": Wall\n    }\n\n/* map is 600 x 400. Size is 20 so we have 30 x 20 tiles */\nvar visual = [\n    \"WWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\"\n]\n\nmodule.exports = Level\n\nfunction Level(map) {\n    visual.forEach(function (row, y) {\n        for (var x = 0; x < row.length; x++) {\n            var block = tileTypes[row[x]](x * SIZE, y * SIZE)\n            if (block) {\n                map.addBlock(block)\n            }\n        }\n    })\n}\n\nfunction noop() {}\n//@ sourceURL=/levels/index.js"));

require.define("/wall/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Widget = require(\"./widget\")\n\nmodule.exports = Widget\n//@ sourceURL=/wall/index.js"));

require.define("/wall/widget.js",Function(['require','module','exports','__dirname','__filename','process'],"var svg = require(\"./wall.svg\")\n    , Element = require(\"svg\")\n\nmodule.exports = Widget\n\nfunction Widget(x, y) {\n    var elem = Element(svg, \"svg\")\n    elem.setAttribute(\"x\", x)\n    elem.setAttribute(\"y\", y)\n\n    return {\n        appendTo: appendTo\n        , x: x\n        , y: y\n    }\n    \n    function appendTo(other) {\n        other.appendChild(elem)\n    }\n}\n//@ sourceURL=/wall/widget.js"));

require.define("/wall/wall.svg",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = '<rect width=\"20\" height=\"20\" fill=\"grey\" stroke=\"black\" />'\n//@ sourceURL=/wall/wall.svg"));

require.define("/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Map = require(\"./map\")\n    , Player = require(\"./player\")\n    , level = require(\"./levels\")\n    , body = document.body\n\nvar map = Map()\n    , player = Player(50, 50)\n\nmap.addEntity(player)\n\nmap.appendTo(body)\n\nlevel(map)\n//@ sourceURL=/index.js"));
require("/index.js");
})();
