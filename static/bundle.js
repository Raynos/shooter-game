(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".html",".svg"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    
    require.define = function (filename, fn) {
        if (require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var queue = [];\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n    \n    if (canPost) {\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n    }\n    \n    return function (fn) {\n        if (canPost) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        }\n        else setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n//@ sourceURL=__browserify_process"));

require.define("vm",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = require(\"vm-browserify\")\n//@ sourceURL=vm"));

require.define("/node_modules/vm-browserify/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/vm-browserify/package.json"));

require.define("/node_modules/vm-browserify/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Object_keys = function (obj) {\n    if (Object.keys) return Object.keys(obj)\n    else {\n        var res = [];\n        for (var key in obj) res.push(key)\n        return res;\n    }\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nvar Script = exports.Script = function NodeScript (code) {\n    if (!(this instanceof Script)) return new Script(code);\n    this.code = code;\n};\n\nScript.prototype.runInNewContext = function (context) {\n    if (!context) context = {};\n    \n    var iframe = document.createElement('iframe');\n    if (!iframe.style) iframe.style = {};\n    iframe.style.display = 'none';\n    \n    document.body.appendChild(iframe);\n    \n    var win = iframe.contentWindow;\n    \n    forEach(Object_keys(context), function (key) {\n        win[key] = context[key];\n    });\n     \n    if (!win.eval && win.execScript) {\n        // win.eval() magically appears when this is called in IE:\n        win.execScript('null');\n    }\n    \n    var res = win.eval(this.code);\n    \n    forEach(Object_keys(win), function (key) {\n        context[key] = win[key];\n    });\n    \n    document.body.removeChild(iframe);\n    \n    return res;\n};\n\nScript.prototype.runInThisContext = function () {\n    return eval(this.code); // maybe...\n};\n\nScript.prototype.runInContext = function (context) {\n    // seems to be just runInNewContext on magical context objects which are\n    // otherwise indistinguishable from objects except plain old objects\n    // for the parameter segfaults node\n    return this.runInNewContext(context);\n};\n\nforEach(Object_keys(Script.prototype), function (name) {\n    exports[name] = Script[name] = function (code) {\n        var s = Script(code);\n        return s[name].apply(s, [].slice.call(arguments, 1));\n    };\n});\n\nexports.createScript = function (code) {\n    return exports.Script(code);\n};\n\nexports.createContext = Script.createContext = function (context) {\n    // not really sure what this one does\n    // seems to just make a shallow copy\n    var copy = {};\n    if(typeof context === 'object') {\n        forEach(Object_keys(context), function (key) {\n            copy[key] = context[key];\n        });\n    }\n    return copy;\n};\n\n//@ sourceURL=/node_modules/vm-browserify/index.js"));

require.define("/map/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Widget = require(\"./widget\")\n    , through = require(\"through\")\n\nmodule.exports = Map\n\nfunction Map() {\n    var widget = Widget(600, 400)\n        , blocks = {}\n        , map = {}\n\n    map.addEntity = addEntity\n    map.addBlock = addBlock\n    map.appendTo = widget.appendTo\n\n    return map\n\n    /*\n        When an entity emit deltas in position we pipe it through a\n            validator which checks collisions and then\n            pipe it back into the entity if the validator thinks there are\n            no collisions\n    */\n    function addEntity(entity) {\n        entity.pipe(through(detectCollisions)).pipe(entity)\n\n        addBlock(entity)\n\n        /*\n\n        */\n        function detectCollisions(data) {\n            //console.log(\"got changes\", data)\n            var changes = data[0]\n                , diffX = changes.x || 0\n                , diffY = changes.y || 0\n                , newX = (entity.x += diffX)\n                , newY = (entity.y += diffY)\n                , loc = getGrid(newX, newY)\n                , list = blocks[loc]\n\n            var isValid = collision(entity, list)\n\n            if (isValid) {\n                var previousLoc = getGrid(entity.x, entity.y)\n\n                if (previousLoc !== loc) {\n                    delete blocks[previousLoc]\n                    blocks[loc] = entity\n                }\n\n                entity.x = newX\n                entity.y = newY\n\n                this.emit(\"data\", [{\n                    x: newX\n                    , y: newY\n                }, data[1], data[2]])\n            } else {\n                entity.x -= diffX\n                entity.y -= diffY\n            }\n        }\n\n        function collision(block, list) {\n            if (!list) {\n                return true\n            }\n\n            return list.every(function (other) {\n                if (block === other) {\n                    return true\n                }\n            })\n        }\n\n        function update(stream, data) {\n            var changes = data[0]\n                , diffX = changes.x || 0\n                , diffY = changes.y || 0\n\n            entity.x += diffX\n            entity.y += diffY\n\n            stream.emit(\"data\", [{\n                x: entity.x\n                , y: entity.y\n            }, data[1], data[2]])\n        }\n    }\n\n    function addBlock(block) {\n        var loc = getGrid(block.x, block.y)\n            , list = blocks[loc]\n\n        if (list) {\n            list.push(block)\n        } else {\n            blocks[loc] = [block]\n        }\n\n        widget.addBlock(block)\n    }\n}\n\nfunction getGrid(x, y) {\n    var diffX = x % 20\n        , diffY = y % 20\n\n    return (x - diffX) + \":\" + (y - diffY)\n}\n//@ sourceURL=/map/index.js"));

require.define("/map/widget.js",Function(['require','module','exports','__dirname','__filename','process'],"var svg = require(\"./map.svg\")\n    , Fragment = require(\"fragment\")\n\nmodule.exports = Widget\n\nfunction Widget(width, height) {\n    var elem = Fragment(svg).firstChild\n    elem.setAttribute(\"width\", width)\n    elem.setAttribute(\"height\", height)\n\n    return {\n        appendTo: appendTo\n        , addBlock: addBlock\n    }\n    \n    function appendTo(other) {\n        other.appendChild(elem)\n    }\n\n    function addBlock(block) {\n        block.appendTo(elem)\n    }\n}\n//@ sourceURL=/map/widget.js"));

require.define("/map/map.svg",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = '<svg class=\"svg-elem\">\\n</svg>'\n//@ sourceURL=/map/map.svg"));

require.define("/node_modules/fragment/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {}\n//@ sourceURL=/node_modules/fragment/package.json"));

require.define("/node_modules/fragment/index.js",Function(['require','module','exports','__dirname','__filename','process'],"Fragment.Element = Element\n\nmodule.exports = Fragment\n\nfunction Fragment(html, elementName) {\n    var el = document.createElement(elementName || \"div\")\n        , fragment = document.createDocumentFragment()\n\n    el.innerHTML = html\n\n    while (el.hasChildNodes()) {\n        fragment.appendChild(el.firstChild)\n    }\n\n    return fragment\n}\n\nfunction Element(html, elementName) {\n    var el = document.createElement(elementName || \"div\")\n\n    el.innerHTML = html\n\n    var child = el.firstChild\n    el.removeChild(child)\n\n    return child\n}\n//@ sourceURL=/node_modules/fragment/index.js"));

require.define("/node_modules/through/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/through/package.json"));

require.define("/node_modules/through/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end) {\n  write = write || function (data) { this.emit('data', data) }\n  end = end || function () { this.emit('end') }\n\n  var ended = false, destroyed = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false  \n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here. \n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  stream.end = function (data) {\n    if(ended) return \n    //this breaks, because pipe doesn't check writable before calling end.\n    //throw new Error('cannot call end twice')\n    ended = true\n    if(arguments.length) stream.write(data)\n    this.writable = false\n    end.call(this)\n    if(!this.readable)\n      this.destroy()\n  }\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    stream.writable = stream.readable = false\n    stream.emit('close')\n  }\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    stream.emit('pause')\n  }\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n      stream.emit('drain')\n    }\n  }\n  return stream\n}\n\n\n//@ sourceURL=/node_modules/through/index.js"));

require.define("stream",Function(['require','module','exports','__dirname','__filename','process'],"var events = require('events');\nvar util = require('util');\n\nfunction Stream() {\n  events.EventEmitter.call(this);\n}\nutil.inherits(Stream, events.EventEmitter);\nmodule.exports = Stream;\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once, and\n  // only when all sources have ended.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    dest._pipeCount = dest._pipeCount || 0;\n    dest._pipeCount++;\n\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (this.listeners('error').length === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('end', cleanup);\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('end', cleanup);\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n//@ sourceURL=stream"));

require.define("events",Function(['require','module','exports','__dirname','__filename','process'],"if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = list.indexOf(listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n//@ sourceURL=events"));

require.define("util",Function(['require','module','exports','__dirname','__filename','process'],"var events = require('events');\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (x === null || typeof x !== 'object') {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Boolean} showHidden Flag that shows hidden (not enumerable)\n *    properties of objects.\n * @param {Number} depth Depth in which to descend in object. Default is 2.\n * @param {Boolean} colors Flag to turn on ANSI escape codes to color the\n *    output. Default is false (no coloring).\n */\nfunction inspect(obj, showHidden, depth, colors) {\n  var ctx = {\n    showHidden: showHidden,\n    seen: [],\n    stylize: colors ? stylizeWithColor : stylizeNoColor\n  };\n  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\nvar colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\nvar styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + colors[style][0] + 'm' + str +\n           '\\u001b[' + colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (value && typeof value.inspect === 'function' &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    return String(value.inspect(recurseTimes));\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object_keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object_getOwnPropertyNames(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (typeof value === 'function') {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (typeof value === 'function') {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  switch (typeof value) {\n    case 'undefined':\n      return ctx.stylize('undefined', 'undefined');\n\n    case 'string':\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                               .replace(/'/g, \"\\\\'\")\n                                               .replace(/\\\\\"/g, '\"') + '\\'';\n      return ctx.stylize(simple, 'string');\n\n    case 'number':\n      return ctx.stylize('' + value, 'number');\n\n    case 'boolean':\n      return ctx.stylize('' + value, 'boolean');\n  }\n  // For some reason typeof null is \"object\", so special case here.\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (Object.prototype.hasOwnProperty.call(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!visibleKeys.hasOwnProperty(key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (recurseTimes === null) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (typeof name === 'undefined') {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== 'object') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction isError(e) {\n  return typeof e === 'object' && objectToString(e) === '[object Error]';\n}\nexports.isError = isError;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\n//@ sourceURL=util"));

require.define("/player/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Widget = require(\"./widget\")\n    , ArrowKeys = require(\"arrow-keys\")\n    , duplex = require(\"duplexer\")\n    , SPEED = 5\n\nmodule.exports = Player\n\n/*\n    A player is a stream which emits requested changes in state and which when\n    written to changes the actual state.\n\n    Generally you hook the input up to the change requests and you hook the\n    state upto the widget for rendering\n*/\nfunction Player(x, y) {\n    var input = ArrowKeys()\n        , widget = Widget(x, y)\n        , player = duplex(widget, input)\n\n    player.appendTo = widget.appendTo\n    player.x = x\n    player.y = y\n\n    return player\n}\n//@ sourceURL=/player/index.js"));

require.define("/player/widget.js",Function(['require','module','exports','__dirname','__filename','process'],"var Element = require(\"svg\")\n    , svg = require(\"./player\")\n    , AttributeStream = require(\"attribute\")\n\nmodule.exports = Widget\n\nfunction Widget(x, y) {\n    var elem = Element(svg)\n        , stream = AttributeStream(elem)\n\n    elem.setAttribute(\"x\", x)\n    elem.setAttribute(\"y\", y)\n\n    stream.appendTo = appendTo\n\n    return stream\n\n    function appendTo(other) {\n        other.appendChild(elem)\n    }\n}\n//@ sourceURL=/player/widget.js"));

require.define("/node_modules/svg/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/svg/package.json"));

require.define("/node_modules/svg/index.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = Element\n\nfunction Element(svgText) {\n    var parser = new DOMParser()\n        , xmlText =  \"<svg xmlns=\\'http://www.w3.org/2000/svg\\'>\" +\n            svgText + \"</svg>\"\n        , docElem = parser.parseFromString(xmlText, \"text/xml\").documentElement\n\n    var node = docElem.firstChild\n    document.importNode(node, true)\n    return node\n}\n//@ sourceURL=/node_modules/svg/index.js"));

require.define("/player/player.svg",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = '<rect width=\"20\" height=\"20\" fill=\"red\" stroke=\"black\" />'\n//@ sourceURL=/player/player.svg"));

require.define("/node_modules/attribute/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/attribute/package.json"));

require.define("/node_modules/attribute/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var forEach = require(\"iterators\").forEachSync\n    , through = require(\"through\")\n\nmodule.exports = AttributeStream\n\nfunction AttributeStream(elem) {\n    var stream = through(updateAttribute)\n\n    return stream\n\n    function updateAttribute(data) {\n        var changes = data[0]\n\n        forEach(changes, setAttribute)\n    }\n\n    function setAttribute(value, key) {\n        elem.setAttribute(key, value)\n    }\n}\n//@ sourceURL=/node_modules/attribute/index.js"));

require.define("/node_modules/iterators/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/iterators/package.json"));

require.define("/node_modules/iterators/index.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\n    // sync\n    forEachSync: require(\"./lib/sync/forEach\")\n    , filterSync: require(\"./lib/sync/filter\")\n    , mapSync: require(\"./lib/sync/map\")\n    , reduceSync: require(\"./lib/sync/reduce\")\n    , reduceRightSync: require(\"./lib/sync/reduceRight\")\n    , everySync: require(\"./lib/sync/every\")\n    , someSync: require(\"./lib/sync/some\")\n    // async\n    , forEach: require(\"./lib/async/forEach\")\n    , filter: require(\"./lib/async/filter\")\n    , map: require(\"./lib/async/map\")\n    , reduce: require(\"./lib/async/reduce\")\n    , reduceRight: require(\"./lib/async/reduceRight\")\n    , every: require(\"./lib/async/every\")\n    , some: require(\"./lib/async/some\")\n}\n//@ sourceURL=/node_modules/iterators/index.js"));

require.define("/node_modules/iterators/lib/sync/forEach.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = forEach\n\nfunction forEach(list, iterator, context) {\n    var keys = Object.keys(list)\n\n    if (arguments.length < 3) {\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        iterator.call(context, value, key, list)\n    }\n}\n//@ sourceURL=/node_modules/iterators/lib/sync/forEach.js"));

require.define("/node_modules/iterators/lib/sync/filter.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = filter\n\nfunction filter(list, iterator, context) {\n    var returnValue = Array.isArray(list) ? [] : {}\n        , keys = Object.keys(list)\n\n    if (arguments.length < 3) {\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n            , keepValue = iterator.call(context, value, key, list)\n\n        if (keepValue) {\n            if (Array.isArray(returnValue)) {\n                returnValue.push(value)\n            } else {\n                returnValue[key] = value\n            }\n        }\n    }\n\n    return returnValue\n}\n//@ sourceURL=/node_modules/iterators/lib/sync/filter.js"));

require.define("/node_modules/iterators/lib/sync/map.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = map\n\nfunction map(list, iterator, context) {\n    var returnValue = Array.isArray(list) ? [] : {}\n        , keys = Object.keys(list)\n\n    if (arguments.length < 3) {\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n            , newValue = iterator.call(context, value, key, list)\n\n        returnValue[key] = newValue\n    }\n\n    return returnValue\n}\n//@ sourceURL=/node_modules/iterators/lib/sync/map.js"));

require.define("/node_modules/iterators/lib/sync/reduce.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = reduce\n\nfunction reduce(list, iterator, context, accumulator) {\n    var keys = Object.keys(list)\n        , i = 0\n\n    if (arguments.length === 2) {\n        context = this\n        accumulator = list[0]\n        i = 1\n    } else if (arguments.length === 3) {\n        accumulator = context\n        context = this\n    }\n\n    for (var len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n\n        accumulator = iterator.call(context, accumulator, value, key, list)\n    }\n\n    return accumulator\n}\n//@ sourceURL=/node_modules/iterators/lib/sync/reduce.js"));

require.define("/node_modules/iterators/lib/sync/reduceRight.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = reduceRight\n\nfunction reduceRight(list, iterator, context, accumulator) {\n    var keys = Object.keys(list)\n        , len = keys.length\n        , i = len - 1\n\n    if (arguments.length === 2) {\n        context = this\n        accumulator = list[i]\n        i--\n    } else if (arguments.length === 3) {\n        accumulator = context\n        context = this\n    }\n\n    for (; i >= 0; i--) {\n        var key = keys[i]\n            , value = list[key]\n\n        accumulator = iterator.call(context, accumulator, value, key, list)\n    }\n\n    return accumulator\n}\n//@ sourceURL=/node_modules/iterators/lib/sync/reduceRight.js"));

require.define("/node_modules/iterators/lib/sync/every.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = every\n\nfunction every(list, iterator, context) {\n    var keys = Object.keys(list)\n        , result\n\n    if (arguments.length < 3) {\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        result = iterator.call(context, value, key, list)\n\n        if (!result) {\n            return result\n        }\n    }\n\n    return result\n}\n//@ sourceURL=/node_modules/iterators/lib/sync/every.js"));

require.define("/node_modules/iterators/lib/sync/some.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = some\n\nfunction some(list, iterator, context) {\n    var keys = Object.keys(list)\n        , result = false\n\n    if (arguments.length < 3) {\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        result = iterator.call(context, value, key, list)\n\n        if (result) {\n            return result\n        }\n    }\n\n    return result\n}\n//@ sourceURL=/node_modules/iterators/lib/sync/some.js"));

require.define("/node_modules/iterators/lib/async/forEach.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = forEach\n\nfunction forEach(list, iterator, context, callback) {\n    var keys = Object.keys(list)\n        , count = keys.length\n\n    if (typeof context === \"function\") {\n        callback = context\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        invokeIterator(iterator, next, context, value, key, list)\n    }\n\n    function next(err) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        if (--count === 0) {\n            callback && callback(null)\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, value, done)\n    } else if (length === 3) {\n        iterator.call(context, value, key, done)\n    } else {\n        iterator.call(context, value, key, list, done)\n    }\n}\n//@ sourceURL=/node_modules/iterators/lib/async/forEach.js"));

require.define("/node_modules/iterators/lib/async/filter.js",Function(['require','module','exports','__dirname','__filename','process'],"var partial = require(\"ap\").partial\n\nmodule.exports = filter\n\nfunction filter(list, iterator, context, callback) {\n    var keys = Object.keys(list)\n        , returnValue = Array.isArray(list) ? [] : {}\n        , count = keys.length\n\n    if (typeof context === \"function\") {\n        callback = context\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        invokeIterator(iterator,\n            partial(next, value, key), context, value, key, list)\n    }\n\n    function next(value, key, err, keepValue) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        if (keepValue) {\n            if (Array.isArray(returnValue)) {\n                returnValue.push(value)\n            } else {\n                returnValue[key] = value\n            }\n        }\n\n        if (--count === 0) {\n            callback && callback(null, returnValue)\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, value, done)\n    } else if (length === 3) {\n        iterator.call(context, value, key, done)\n    } else {\n        iterator.call(context, value, key, list, done)\n    }\n}\n//@ sourceURL=/node_modules/iterators/lib/async/filter.js"));

require.define("/node_modules/iterators/node_modules/ap/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"./index.js\"}\n//@ sourceURL=/node_modules/iterators/node_modules/ap/package.json"));

require.define("/node_modules/iterators/node_modules/ap/index.js",Function(['require','module','exports','__dirname','__filename','process'],"exports = module.exports = ap;\nfunction ap (args, fn) {\n    return function () {\n        return fn.apply(this, args.concat.apply(args, arguments));\n    };\n}\n\nexports.pa = pa;\nfunction pa (args, fn) {\n    return function () {\n        return fn.apply(this, [].slice.call(arguments).concat(args));\n    };\n}\n\nexports.apa = apa;\nfunction apa (left, right, fn) {\n    return function () {\n        return fn.apply(this,\n            left.concat.apply(left, arguments).concat(right)\n        );\n    };\n}\n\nexports.partial = partial;\nfunction partial (fn) {\n    var args = [].slice.call(arguments, 1);\n    return ap(args, fn);\n}\n\nexports.partialRight = partialRight;\nfunction partialRight (fn) {\n    var args = [].slice.call(arguments, 1);\n    return pa(args, fn);\n}\n\nexports.curry = curry;\nfunction curry (fn) {\n    return partial(partial, fn);\n}\n\nexports.curryRight = function curryRight (fn) {\n    return partial(partialRight, fn);\n}\n\n//@ sourceURL=/node_modules/iterators/node_modules/ap/index.js"));

require.define("/node_modules/iterators/lib/async/map.js",Function(['require','module','exports','__dirname','__filename','process'],"var partial = require(\"ap\").partial\n\nmodule.exports = map\n\nfunction map(list, iterator, context, callback) {\n    var keys = Object.keys(list)\n        , returnValue = Array.isArray(list) ? [] : {}\n        , count = keys.length\n\n    if (typeof context === \"function\") {\n        callback = context\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        invokeIterator(iterator,\n            partial(next, key), context, value, key, list)\n    }\n\n    function next(key, err, newValue) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        returnValue[key] = newValue\n\n        if (--count === 0) {\n            callback && callback(null, returnValue)\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, value, done)\n    } else if (length === 3) {\n        iterator.call(context, value, key, done)\n    } else {\n        iterator.call(context, value, key, list, done)\n    }\n}\n//@ sourceURL=/node_modules/iterators/lib/async/map.js"));

require.define("/node_modules/iterators/lib/async/reduce.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = reduce\n\nfunction reduce(list, iterator, context, accumulator, callback) {\n    var keys = Object.keys(list)\n        , count = keys.length\n\n    if (arguments.length === 3) {\n        callback = context\n        context = this\n        accumulator = list[0]\n        keys.shift()\n        count--\n    } else if (arguments.length === 4) {\n        callback = accumulator\n        accumulator = context\n        context = this\n    }\n\n    go()\n\n    function go() {\n        var key = keys.shift()\n            , value = list[key]\n\n        invokeIterator(iterator, next, context, accumulator, value, key, list)\n    }\n\n    function next(err, value) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        accumulator = value\n\n        if (--count === 0) {\n            callback && callback(null, accumulator)\n        } else {\n            go()\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, acc, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, acc, done)\n    } else if (length === 3) {\n        iterator.call(context, acc, value, done)\n    } else if (length === 4) {\n        iterator.call(context, acc, value, key, done)\n    } else {\n        iterator.call(context, acc, value, key, list, done)\n    }\n}\n//@ sourceURL=/node_modules/iterators/lib/async/reduce.js"));

require.define("/node_modules/iterators/lib/async/reduceRight.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = forEach\n\nfunction forEach(list, iterator, context, accumulator, callback) {\n    var keys = Object.keys(list)\n        , len = keys.length\n        , count = keys.length\n\n    if (arguments.length === 3) {\n        callback = context\n        context = this\n        accumulator = list[len - 1]\n        keys.pop()\n        count--\n    } else if (arguments.length === 4) {\n        callback = accumulator\n        accumulator = context\n        context = this\n    }\n\n    go()\n\n    function go() {\n        var key = keys.pop()\n            , value = list[key]\n\n        invokeIterator(iterator, next, context, accumulator, value, key, list)\n    }\n\n    function next(err, value) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        accumulator = value\n\n        if (--count === 0) {\n            callback && callback(null, accumulator)\n        } else {\n            go()\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, acc, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, acc, done)\n    } else if (length === 3) {\n        iterator.call(context, acc, value, done)\n    } else if (length === 4) {\n        iterator.call(context, acc, value, key, done)\n    } else {\n        iterator.call(context, acc, value, key, list, done)\n    }\n}\n//@ sourceURL=/node_modules/iterators/lib/async/reduceRight.js"));

require.define("/node_modules/iterators/lib/async/every.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = every\n\nfunction every(list, iterator, context, callback) {\n    var keys = Object.keys(list)\n        , count = keys.length\n\n    if (typeof context === \"function\") {\n        callback = context\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        invokeIterator(iterator, next, context, value, key, list)\n    }\n\n    function next(err, result) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        if (!result) {\n            return callback && callback(null, result)\n        }\n\n        if (--count === 0) {\n            callback && callback(null, result)\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, value, done)\n    } else if (length === 3) {\n        iterator.call(context, value, key, done)\n    } else {\n        iterator.call(context, value, key, list, done)\n    }\n}\n//@ sourceURL=/node_modules/iterators/lib/async/every.js"));

require.define("/node_modules/iterators/lib/async/some.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = forEach\n\nfunction forEach(list, iterator, context, callback) {\n    var keys = Object.keys(list)\n        , count = keys.length\n\n    if (typeof context === \"function\") {\n        callback = context\n        context = this\n    }\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i]\n            , value = list[key]\n        \n        invokeIterator(iterator, next, context, value, key, list)\n    }\n\n    function next(err, result) {\n        if (err) {\n            return callback && callback(err)\n        }\n\n        if (result) {\n            return callback && callback(null, result)\n        }\n\n        if (--count === 0) {\n            callback && callback(null, result)\n        }\n    }\n}\n\nfunction invokeIterator(iterator, done, context, value, key, list) {\n    var length = iterator.length\n\n    if (length === 1) {\n        iterator.call(context, done)\n    } else if (length === 2) {\n        iterator.call(context, value, done)\n    } else if (length === 3) {\n        iterator.call(context, value, key, done)\n    } else {\n        iterator.call(context, value, key, list, done)\n    }\n}\n//@ sourceURL=/node_modules/iterators/lib/async/some.js"));

require.define("/node_modules/arrow-keys/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/arrow-keys/package.json"));

require.define("/node_modules/arrow-keys/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var through = require(\"through\")\n    , uuid = require(\"node-uuid\")\n    , KEYS = {\n        \"37\": \"left\"\n        , \"38\": \"up\"\n        , \"39\": \"right\"\n        , \"40\": \"down\"\n    }\n    , down = {}\n\nwindow.addEventListener(\"keyup\", onup)\nwindow.addEventListener(\"keydown\", ondown)\n\nmodule.exports = ArrowKeys\n\nfunction ArrowKeys(fps) {\n    var stream = through()\n        , id = uuid()\n\n    fps = fps || 60\n\n    var timeOffset = 1000.0 / fps\n\n    setTimeout(move, timeOffset)\n    \n    return stream\n\n    function move() {\n        var changes = getChanges()\n\n        if (changes) {\n            stream.write([changes, Date.now(), id])\n        }\n\n        setTimeout(move, timeOffset)\n    }\n}\n\nfunction ondown(event) {\n    var key = KEYS[event.which]\n    down[key] = true\n}\n\nfunction onup(event) {\n    var key = KEYS[event.which]\n    down[key] = false\n}\n\nfunction getChanges() {\n    var x, y\n    if (down.up) {\n        y = -1\n    } else if (down.down) {\n        y = 1\n    }\n\n    if (down.left) {\n        x = -1\n    } else if (down.right) {\n        x = 1\n    }\n\n    if (!x && !y) {\n        return null\n    }\n\n    return {\n        x: x\n        , y: y\n    }\n}\n//@ sourceURL=/node_modules/arrow-keys/index.js"));

require.define("/node_modules/node-uuid/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"./uuid.js\"}\n//@ sourceURL=/node_modules/node-uuid/package.json"));

require.define("/node_modules/node-uuid/uuid.js",Function(['require','module','exports','__dirname','__filename','process'],"//     node-uuid/uuid.js\n//\n//     Copyright (c) 2010 Robert Kieffer\n//     Dual licensed under the MIT and GPL licenses.\n//     Documentation and details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  // Unique ID creation requires a high quality random # generator, but\n  // Math.random() does not guarantee \"cryptographic quality\".  So we feature\n  // detect for more robust APIs, normalizing each method to return 128-bits\n  // (16 bytes) of random data.\n  var mathRNG, nodeRNG, whatwgRNG;\n\n  // Math.random()-based RNG.  All platforms, very fast, unknown quality\n  var _rndBytes = new Array(16);\n  mathRNG = function() {\n    var r, b = _rndBytes, i = 0;\n\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      b[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return b;\n  }\n\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // WebKit only (currently), moderately fast, high quality\n  if (_global.crypto && crypto.getRandomValues) {\n    var _rnds = new Uint32Array(4);\n    whatwgRNG = function() {\n      crypto.getRandomValues(_rnds);\n\n      for (var c = 0 ; c < 16; c++) {\n        _rndBytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;\n      }\n      return _rndBytes;\n    }\n  }\n\n  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html\n  // Node.js only, moderately fast, high quality\n  try {\n    var _rb = require('crypto').randomBytes;\n    nodeRNG = _rb && function() {\n      return _rb(16);\n    };\n  } catch (e) {}\n\n  // Select RNG with best quality\n  var _rng = nodeRNG || whatwgRNG || mathRNG;\n\n  // Buffer class to use\n  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;\n\n  // Maps for number <-> hex string conversion\n  var _byteToHex = [];\n  var _hexToByte = {};\n  for (var i = 0; i < 256; i++) {\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    _hexToByte[_byteToHex[i]] = i;\n  }\n\n  // **`parse()` - Parse a UUID into it's component bytes**\n  function parse(s, buf, offset) {\n    var i = (buf && offset) || 0, ii = 0;\n\n    buf = buf || [];\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(byte) {\n      if (ii < 16) { // Don't overflow!\n        buf[i + ii++] = _hexToByte[byte];\n      }\n    });\n\n    // Zero out remaining bytes if string was short\n    while (ii < 16) {\n      buf[i + ii++] = 0;\n    }\n\n    return buf;\n  }\n\n  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n  function unparse(buf, offset) {\n    var i = offset || 0, bth = _byteToHex;\n    return  bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]];\n  }\n\n  // **`v1()` - Generate time-based UUID**\n  //\n  // Inspired by https://github.com/LiosK/UUID.js\n  // and http://docs.python.org/library/uuid.html\n\n  // random #'s we need to init node and clockseq\n  var _seedBytes = _rng();\n\n  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n  var _nodeId = [\n    _seedBytes[0] | 0x01,\n    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n  ];\n\n  // Per 4.2.2, randomize (14 bit) clockseq\n  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n  // Previous uuid creation time\n  var _lastMSecs = 0, _lastNSecs = 0;\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n\n    options = options || {};\n\n    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;\n\n    // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n    var msecs = options.msecs != null ? options.msecs : new Date().getTime();\n\n    // Per 4.2.1.2, use count of uuid's generated during the current clock\n    // cycle to simulate higher resolution clock\n    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;\n\n    // Time since last uuid creation (in msecs)\n    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n    // Per 4.2.1.2, Bump clockseq on clock regression\n    if (dt < 0 && options.clockseq == null) {\n      clockseq = clockseq + 1 & 0x3fff;\n    }\n\n    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n    // time interval\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {\n      nsecs = 0;\n    }\n\n    // Per 4.2.1.2 Throw error if too many uuids are requested\n    if (nsecs >= 10000) {\n      throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n    }\n\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n\n    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n    msecs += 12219292800000;\n\n    // `time_low`\n    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    b[i++] = tl >>> 24 & 0xff;\n    b[i++] = tl >>> 16 & 0xff;\n    b[i++] = tl >>> 8 & 0xff;\n    b[i++] = tl & 0xff;\n\n    // `time_mid`\n    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n    b[i++] = tmh >>> 8 & 0xff;\n    b[i++] = tmh & 0xff;\n\n    // `time_high_and_version`\n    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n    b[i++] = tmh >>> 16 & 0xff;\n\n    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n    b[i++] = clockseq >>> 8 | 0x80;\n\n    // `clock_seq_low`\n    b[i++] = clockseq & 0xff;\n\n    // `node`\n    var node = options.node || _nodeId;\n    for (var n = 0; n < 6; n++) {\n      b[i + n] = node[n];\n    }\n\n    return buf ? buf : unparse(b);\n  }\n\n  // **`v4()` - Generate random UUID**\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v4(options, buf, offset) {\n    // Deprecated - 'format' argument, as supported in v1.2\n    var i = buf && offset || 0;\n\n    if (typeof(options) == 'string') {\n      buf = options == 'binary' ? new BufferClass(16) : null;\n      options = null;\n    }\n    options = options || {};\n\n    var rnds = options.random || (options.rng || _rng)();\n\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n    // Copy bytes to buffer, if provided\n    if (buf) {\n      for (var ii = 0; ii < 16; ii++) {\n        buf[i + ii] = rnds[ii];\n      }\n    }\n\n    return buf || unparse(rnds);\n  }\n\n  // Export public API\n  var uuid = v4;\n  uuid.v1 = v1;\n  uuid.v4 = v4;\n  uuid.parse = parse;\n  uuid.unparse = unparse;\n  uuid.BufferClass = BufferClass;\n\n  // Export RNG options\n  uuid.mathRNG = mathRNG;\n  uuid.nodeRNG = nodeRNG;\n  uuid.whatwgRNG = whatwgRNG;\n\n  if (typeof(module) != 'undefined') {\n    // Play nice with node.js\n    module.exports = uuid;\n  } else {\n    // Play nice with browsers\n    var _previousRoot = _global.uuid;\n\n    // **`noConflict()` - (browser only) to reset global 'uuid' var**\n    uuid.noConflict = function() {\n      _global.uuid = _previousRoot;\n      return uuid;\n    }\n    _global.uuid = uuid;\n  }\n}());\n\n//@ sourceURL=/node_modules/node-uuid/uuid.js"));

require.define("crypto",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = require(\"crypto-browserify\")\n//@ sourceURL=crypto"));

require.define("/node_modules/crypto-browserify/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {}\n//@ sourceURL=/node_modules/crypto-browserify/package.json"));

require.define("/node_modules/crypto-browserify/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var sha = require('./sha')\nvar rng = require('./rng')\n\nvar algorithms = {\n  sha1: {\n    hex: sha.hex_sha1,\n    binary: sha.b64_sha1,\n    ascii: sha.str_sha1\n  }\n}\n\nfunction error () {\n  var m = [].slice.call(arguments).join(' ')\n  throw new Error([\n    m,\n    'we accept pull requests',\n    'http://github.com/dominictarr/crypto-browserify'\n    ].join('\\n'))\n}\n\nexports.createHash = function (alg) {\n  alg = alg || 'sha1'\n  if(!algorithms[alg])\n    error('algorithm:', alg, 'is not yet supported')\n  var s = ''\n  var _alg = algorithms[alg]\n  return {\n    update: function (data) {\n      s += data\n      return this\n    },\n    digest: function (enc) {\n      enc = enc || 'binary'\n      var fn\n      if(!(fn = _alg[enc]))\n        error('encoding:', enc , 'is not yet supported for algorithm', alg)\n      var r = fn(s)\n      s = null //not meant to use the hash after you've called digest.\n      return r\n    }\n  }\n}\n\nexports.randomBytes = function(size, callback) {\n  if (callback && callback.call) {\n    try {\n      callback.call(this, undefined, rng(size));\n    } catch (err) { callback(err); }\n  } else {\n    return rng(size);\n  }\n}\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\n;['createCredentials'\n, 'createHmac'\n, 'createCypher'\n, 'createCypheriv'\n, 'createDecipher'\n, 'createDecipheriv'\n, 'createSign'\n, 'createVerify'\n, 'createDeffieHellman'\n, 'pbkdf2'].forEach(function (name) {\n  exports[name] = function () {\n    error('sorry,', name, 'is not implemented yet')\n  }\n})\n\n//@ sourceURL=/node_modules/crypto-browserify/index.js"));

require.define("/node_modules/crypto-browserify/sha.js",Function(['require','module','exports','__dirname','__filename','process'],"/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nexports.hex_sha1 = hex_sha1;\nexports.b64_sha1 = b64_sha1;\nexports.str_sha1 = str_sha1;\nexports.hex_hmac_sha1 = hex_hmac_sha1;\nexports.b64_hmac_sha1 = b64_hmac_sha1;\nexports.str_hmac_sha1 = str_hmac_sha1;\n\n/*\n * Configurable variables. You may need to tweak these to be compatible with\n * the server-side, but the defaults work in most cases.\n */\nvar hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */\nvar b64pad  = \"\"; /* base-64 pad character. \"=\" for strict RFC compliance   */\nvar chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */\n\n/*\n * These are the functions you'll usually want to call\n * They take string arguments and return either hex or base-64 encoded strings\n */\nfunction hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}\nfunction b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}\nfunction str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}\nfunction hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}\nfunction b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}\nfunction str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}\n\n/*\n * Perform a simple self-test to see if the VM is working\n */\nfunction sha1_vm_test()\n{\n  return hex_sha1(\"abc\") == \"a9993e364706816aba3e25717850c26c9cd0d89d\";\n}\n\n/*\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\n */\nfunction core_sha1(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << (24 - len % 32);\n  x[((len + 64 >> 9) << 4) + 15] = len;\n\n  var w = Array(80);\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n  var e = -1009589776;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    var olde = e;\n\n    for(var j = 0; j < 80; j++)\n    {\n      if(j < 16) w[j] = x[i + j];\n      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n    e = safe_add(e, olde);\n  }\n  return Array(a, b, c, d, e);\n\n}\n\n/*\n * Perform the appropriate triplet combination function for the current\n * iteration\n */\nfunction sha1_ft(t, b, c, d)\n{\n  if(t < 20) return (b & c) | ((~b) & d);\n  if(t < 40) return b ^ c ^ d;\n  if(t < 60) return (b & c) | (b & d) | (c & d);\n  return b ^ c ^ d;\n}\n\n/*\n * Determine the appropriate additive constant for the current iteration\n */\nfunction sha1_kt(t)\n{\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n         (t < 60) ? -1894007588 : -899497514;\n}\n\n/*\n * Calculate the HMAC-SHA1 of a key and some data\n */\nfunction core_hmac_sha1(key, data)\n{\n  var bkey = str2binb(key);\n  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);\n\n  var ipad = Array(16), opad = Array(16);\n  for(var i = 0; i < 16; i++)\n  {\n    ipad[i] = bkey[i] ^ 0x36363636;\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\n  }\n\n  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);\n  return core_sha1(opad.concat(hash), 512 + 160);\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\n/*\n * Convert an 8-bit or 16-bit string to an array of big-endian words\n * In 8-bit function, characters >255 have their hi-byte silently ignored.\n */\nfunction str2binb(str)\n{\n  var bin = Array();\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < str.length * chrsz; i += chrsz)\n    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);\n  return bin;\n}\n\n/*\n * Convert an array of big-endian words to a string\n */\nfunction binb2str(bin)\n{\n  var str = \"\";\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < bin.length * 32; i += chrsz)\n    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);\n  return str;\n}\n\n/*\n * Convert an array of big-endian words to a hex string.\n */\nfunction binb2hex(binarray)\n{\n  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i++)\n  {\n    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +\n           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);\n  }\n  return str;\n}\n\n/*\n * Convert an array of big-endian words to a base-64 string\n */\nfunction binb2b64(binarray)\n{\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i += 3)\n  {\n    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)\n                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )\n                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);\n    for(var j = 0; j < 4; j++)\n    {\n      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;\n      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);\n    }\n  }\n  return str;\n}\n\n\n//@ sourceURL=/node_modules/crypto-browserify/sha.js"));

require.define("/node_modules/crypto-browserify/rng.js",Function(['require','module','exports','__dirname','__filename','process'],"// Original code adapted from Robert Kieffer.\n// details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  var mathRNG, whatwgRNG;\n\n  // NOTE: Math.random() does not guarantee \"cryptographic quality\"\n  mathRNG = function(size) {\n    var bytes = new Array(size);\n    var r;\n\n    for (var i = 0, r; i < size; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return bytes;\n  }\n\n  // currently only available in webkit-based browsers.\n  if (_global.crypto && crypto.getRandomValues) {\n    var _rnds = new Uint32Array(4);\n    whatwgRNG = function(size) {\n      var bytes = new Array(size);\n      crypto.getRandomValues(_rnds);\n\n      for (var c = 0 ; c < size; c++) {\n        bytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;\n      }\n      return bytes;\n    }\n  }\n\n  module.exports = whatwgRNG || mathRNG;\n\n}())\n//@ sourceURL=/node_modules/crypto-browserify/rng.js"));

require.define("/node_modules/duplexer/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/duplexer/package.json"));

require.define("/node_modules/duplexer/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Stream = require(\"stream\")\n    , writeMethods = [\"write\", \"end\", \"destroy\"]\n    , readMethods = [\"resume\", \"pause\"]\n    , readEvents = [\"data\", \"close\"]\n    , slice = Array.prototype.slice\n\nmodule.exports = duplex\n\nfunction duplex(writer, reader) {\n    var stream = new Stream()\n        , ended = false\n\n    Object.defineProperties(stream, {\n        writable: {\n            get: getWritable\n        }\n        , readable: {\n            get: getReadable\n        }\n    })\n\n    writeMethods.forEach(proxyWriter)\n\n    readMethods.forEach(proxyReader)\n\n    readEvents.forEach(proxyStream)\n\n    reader.on(\"end\", handleEnd)\n\n    writer.on(\"error\", reemit)\n    reader.on(\"error\", reemit)\n\n    return stream\n\n    function getWritable() {\n        return writer.writable\n    }\n\n    function getReadable() {\n        return reader.readable\n    }\n\n    function proxyWriter(methodName) {\n        stream[methodName] = method\n\n        function method() {\n            return writer[methodName].apply(writer, arguments)\n        }\n    }\n\n    function proxyReader(methodName) {\n        stream[methodName] = method\n\n        function method() {\n            stream.emit(methodName)\n            var func = reader[methodName]\n            if (func) {\n                return func.apply(reader, arguments)\n            }\n            reader.emit(methodName)\n        }\n    }\n\n    function proxyStream(methodName) {\n        reader.on(methodName, reemit)\n\n        function reemit() {\n            var args = slice.call(arguments)\n            args.unshift(methodName)\n            stream.emit.apply(stream, args)\n        }\n    }\n\n    function handleEnd() {\n        if (ended) {\n            return\n        }\n        ended = true\n        var args = slice.call(arguments)\n        args.unshift(\"end\")\n        stream.emit.apply(stream, args)\n    }\n\n    function reemit(err) {\n        stream.emit(\"error\", err)\n    }\n}\n//@ sourceURL=/node_modules/duplexer/index.js"));

require.define("/levels/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Wall = require(\"../wall\")\n    , SIZE = 20\n    , tileTypes = {\n        \"E\": noop\n        , \"W\": Wall\n    }\n\n/* map is 600 x 400. Size is 20 so we have 30 x 20 tiles */\nvar visual = [\n    \"WWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WEEEEEEEEEEEEEEEEEEEEEEEEEEEEW\"\n    , \"WWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\"\n]\n\nmodule.exports = Level\n\nfunction Level(map) {\n    visual.forEach(function (row, y) {\n        for (var x = 0; x < row.length; x++) {\n            var block = tileTypes[row[x]](x * SIZE, y * SIZE)\n            if (block) {\n                map.addBlock(block)\n            }\n        }\n    })\n}\n\nfunction noop() {}\n//@ sourceURL=/levels/index.js"));

require.define("/wall/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Widget = require(\"./widget\")\n\nmodule.exports = Widget\n//@ sourceURL=/wall/index.js"));

require.define("/wall/widget.js",Function(['require','module','exports','__dirname','__filename','process'],"var svg = require(\"./wall.svg\")\n    , Element = require(\"svg\")\n\nmodule.exports = Widget\n\nfunction Widget(x, y) {\n    var elem = Element(svg, \"svg\")\n    elem.setAttribute(\"x\", x)\n    elem.setAttribute(\"y\", y)\n\n    return {\n        appendTo: appendTo\n        , x: x\n        , y: y\n    }\n    \n    function appendTo(other) {\n        other.appendChild(elem)\n    }\n}\n//@ sourceURL=/wall/widget.js"));

require.define("/wall/wall.svg",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = '<rect width=\"20\" height=\"20\" fill=\"grey\" stroke=\"black\" />'\n//@ sourceURL=/wall/wall.svg"));

require.define("/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var Map = require(\"./map\")\n    , Player = require(\"./player\")\n    , level = require(\"./levels\")\n    , body = document.body\n\nvar map = Map()\n    , player = Player(50, 50)\n\nmap.addEntity(player)\n\nmap.appendTo(body)\n\nlevel(map)\n//@ sourceURL=/index.js"));
require("/index.js");
})();
